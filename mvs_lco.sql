-- MySQL dump 10.13  Distrib 5.1.41, for debian-linux-gnu (x86_64)
--
-- Host: localhost    Database: mvs_lco
-- ------------------------------------------------------
-- Server version	5.1.41-3ubuntu12.6-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `mvs_functions`
--

DROP TABLE IF EXISTS `mvs_functions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mvs_functions` (
  `function_id` int(11) NOT NULL AUTO_INCREMENT,
  `function_GUID` varchar(32) NOT NULL,
  `inputs` text NOT NULL,
  `content` text NOT NULL,
  PRIMARY KEY (`function_id`),
  UNIQUE KEY `function_GUID` (`function_GUID`)
) ENGINE=InnoDB AUTO_INCREMENT=122 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mvs_functions`
--

LOCK TABLES `mvs_functions` WRITE;
/*!40000 ALTER TABLE `mvs_functions` DISABLE KEYS */;
INSERT INTO `mvs_functions` VALUES (21,'media_mime','[\"RawMedia\"]','$Media=$RawMedia;\n\nif (substr($RawMedia[\"mimetype\"],0,4)==\"text\") $Media[\"content\"]=htmlspecialchars($RawMedia[\"content\"]);\n//stripslashes(htmlspecialchars($RawMedia[\"content\"]));\nreturn $Media;'),(22,'post_media','','$GUID=$GLOBALS->_POST[\"GUID\"];\n\nif ($GUID != \"upload\"){\n\n	$inputs=Array();\n	$posted_inputs=json_decode($GLOBALS->_POST[\"inputs\"]);\n	foreach ($posted_inputs as $input) $inputs[$input]=Array();\n	\n	$data=Array(\n		\"mimetype\"=>$GLOBALS->_POST[\"mimetype\"],\n		\"content\"=>$GLOBALS->_POST[\"content\"],\n		\"inputs\"=>$inputs \n		);\n\n	if ($GUID==\"new\" || trim($GUID)===\"\" ) $GUID = null;\n\n}else{\n\n	$GUID = null;\n	$tmp_name=$GLOBALS->_FILES[\"filecontent\"][\"tmp_name\"];\n	$mime_type=$GLOBALS->_FILES[\"filecontent\"][\"type\"];\n	$file_content=file_get_contents($tmp_name);\n\n	$data=Array(\n		\"mimetype\"=>$mime_type,\n		\"content\"=>$file_content\n		);\n}\n\n$package=$GLOBALS->_POST[\"package_id\"];\n$interface=$GLOBALS->_POST[\"interface_id\"];\n\nif ( isset($GLOBALS->_POST[\'new_package\']) && trim($GLOBALS->_POST[\'new_package\']) != \"\") {\n	$create_package=Movabls::set_movabl(\"package\",Array(\"meta\"=>Array(\"label\"=>$GLOBALS->_POST[\'new_package\'])) );\n	Movabls_Permissions::set_movabl_permissions(\"package\",$create_package,array(array(\'id\'=>1,\'read\'=>1,\'write\'=>1,\'execute\'=>1)));\n	$package=$create_package;\n}\n\n\nif ( isset($GLOBALS->_POST[\'new_interface\']) && trim($GLOBALS->_POST[\'new_interface\']) != \"\") {\n	$create_interface=Movabls::set_movabl(\"interface\",Array(\"meta\"=>Array(\"label\"=>$GLOBALS->_POST[\'new_interface\'])) );\n	Movabls_Permissions::set_movabl_permissions(\"interface\",$create_interface,array(array(\'id\'=>1,\'read\'=>1,\'write\'=>1,\'execute\'=>1)));\n	$interface=$create_interface;\n	if ($package !=\"\") Movabls::add_to_package($package,\"interface\", $interface);\n}\n\n\nif ($GUID!=\"upload\"){\n\n	if (isset($GLOBALS->_POST[\"label\"])) $data[\"meta\"]= Array (\"label\"=>$GLOBALS->_POST[\"label\"]);\n\n	$GUID=Movabls::set_movabl(\"media\",$data, $GUID);\n	Movabls_Permissions::set_movabl_permissions(\"media\",$GUID,array(array(\'id\'=>1,\'read\'=>1,\'write\'=>1,\'execute\'=>1)));\n	if ($package !=\"\") Movabls::add_to_package($package,\"media\", $GUID);\n\n	if (isset($GLOBALS->_POST[\"place_url\"])){\n\n		$data=Array(\n			\"url\"=>utf8_encode($GLOBALS->_POST[\"place_url\"]),\n			\"media_GUID\"=>$GUID,\n			\"interface_GUID\"=>$interface\n		);\n\n		if (isset($GLOBALS->_POST[\"label\"])) $data[\"meta\"][\"label\"] = $GLOBALS->_POST[\"label\"];\n		$data[\"meta\"][\"parent\"] = \"root\";\n\n		$place_GUID=Movabls::set_movabl(\"place\",$data);\n		Movabls_Permissions::set_movabl_permissions(\"place\",$place_GUID,array(array(\'id\'=>1,\'read\'=>1,\'write\'=>1,\'execute\'=>1)));\necho $GLOBALS->_POST[\"group_id\"];\nif ($GLOBALS->_POST[\"group_id\"] != \"1\")\nMovabls_Permissions::set_movabl_permissions(\"place\",$place_GUID, Array( Array(\'id\'=>$GLOBALS->_POST[\"group_id\"],\'read\'=>TRUE,\'write\'=>FALSE,\'execute\'=>TRUE) ) ) ;\n\n		if ($package !=\"\") Movabls::add_to_package($package,\"place\", $place_GUID);\n\n		return date(\"h:i:s A\");\n\n	}else{\n		return date(\"h:i:s A\");\n	}\n}'),(23,'encode_inputs','[\"Movabl\"]','$inputs = Array();\nforeach ($Movabl[\"inputs\"] as $input=>$array) $inputs[]=$input;\n\nreturn json_encode($inputs);'),(24,'post_function','','$inputs=Array();\n\nif (isset($GLOBALS->_POST[\"inputs\"]) ){\n$posted_inputs=json_decode($GLOBALS->_POST[\"inputs\"]);\n\nforeach ($posted_inputs as $input)\n$inputs[$input]=Array();\n}\n$data=Array(\n\"inputs\"=>$inputs,\n\"content\"=>$GLOBALS->_POST[\"content\"]\n);\n\n\n\n\n$package=$GLOBALS->_POST[\"package_id\"];\n\nif ( isset($GLOBALS->_POST[\'new_package\']) && trim($GLOBALS->_POST[\'new_package\']) != \"\") {\n	$create_package=Movabls::set_movabl(\"package\",Array(\"meta\"=>Array(\"label\"=>$GLOBALS->_POST[\'new_package\'])) );\n	Movabls_Permissions::set_movabl_permissions(\"package\",$create_package,array(array(\'id\'=>1,\'read\'=>1,\'write\'=>1,\'execute\'=>1)));\n	$package=$create_package;\n}\n\n\n\nif (isset($GLOBALS->_POST[\"label\"])) $data[\"meta\"]= Array (\"label\"=>$GLOBALS->_POST[\"label\"]);\n\n//TODO fix this globally/delete this line and in post_interface\ndate_default_timezone_set(\'America/New_York\');\n\nif ($GLOBALS->_POST[\"GUID\"]!=\"new\") $GUID=$GLOBALS->_POST[\"GUID\"];\nelse $GUID = null;\n\n$GUID=Movabls::set_movabl(\"function\",$data, $GLOBALS->_POST[\"GUID\"]);\nMovabls_Permissions::set_movabl_permissions(\"function\",$GUID,array(array(\'id\'=>1,\'read\'=>1,\'write\'=>1,\'execute\'=>1)));\n\n	if ($package !=\"\") Movabls::add_to_package($package,\"function\", $GUID);\n\n\nif ($GUID !=\"\") return date(\"h:i:s A\").\" \".$GUID;\nelse return \"error in set_function\";\n'),(47,'post_interface','','//TODO make this an interface\n$json_content=json_decode($GLOBALS->_POST[\"json\"],TRUE);\n\n$data=Array(\n\"content\"=>$json_content\n);\n\nif (isset($GLOBALS->_POST[\"label\"])) $data[\"meta\"][\"label\"] = $GLOBALS->_POST[\"label\"];\n\n//TODO fix this globally/delete this line and in post_function\ndate_default_timezone_set(\'America/New_York\');\n\n$GUID=Movabls::set_movabl(\"interface\",$data, $GLOBALS->_POST[\"GUID\"]);\nMovabls_Permissions::set_movabl_permissions(\"interface\",$GUID,array(array(\'id\'=>1,\'read\'=>1,\'write\'=>1,\'execute\'=>1)));\n\nif ($GUID !=\"\") return date(\"h:i:s A\").\" \".$GUID;\nelse return \"error in post_interface\";\n'),(48,'mapinterface','[\"Interface_Input\"]','    $tab = \"  \"; \n    $new_json = \"\"; \n    $indent_level = 0; \n    $in_string = false; \n\n    \n    $json = json_encode($Interface_Input[\"content\"]); \n    $len = strlen($json); \n\n    for($c = 0; $c < $len; $c++) \n    { \n        $char = $json[$c]; \n        switch($char) \n        { \n            case \'{\': \n            case \'[\': \n                if(!$in_string) \n                { \n                    $new_json .= $char . \"\\n\" . str_repeat($tab, $indent_level+1); \n                    $indent_level++; \n                } \n                else \n                { \n                    $new_json .= $char; \n                } \n                break; \n            case \'}\': \n            case \']\': \n                if(!$in_string) \n                { \n                    $indent_level--; \n                    $new_json .= \"\\n\" . str_repeat($tab, $indent_level) . $char; \n                } \n                else \n                { \n                    $new_json .= $char; \n                } \n                break; \n            case \',\': \n                if(!$in_string) \n                { \n                    $new_json .= \",\\n\" . str_repeat($tab, $indent_level); \n                } \n                else \n                { \n                    $new_json .= $char; \n                } \n                break; \n            case \':\': \n                if(!$in_string) \n                { \n                    $new_json .= \": \"; \n                } \n                else \n                { \n                    $new_json .= $char; \n                } \n                break; \n            case \'\"\': \n                if($c > 0 && $json[$c-1] != \'\\\\\') \n                { \n                    $in_string = !$in_string; \n                } \n            default: \n                $new_json .= $char; \n                break;                    \n        } \n    } \n\n    return $new_json;\n'),(49,'post_place','','//TODO - replace these globals with proper ints\n\n$data=Array(\n\"url\"=>utf8_encode($GLOBALS->_POST[\"place_url\"]),\n\"media_GUID\"=>$GLOBALS->_POST[\"media_id\"],\n\"interface_GUID\"=>$GLOBALS->_POST[\"interface_id\"]\n);\n\nif (isset($GLOBALS->_POST[\"label\"])) $data[\"meta\"][\"label\"] = $GLOBALS->_POST[\"label\"];\nif (isset($GLOBALS->_POST[\"parent\"])) $data[\"meta\"][\"parent\"] = $GLOBALS->_POST[\"parent\"];\n\n\n$GUID=Movabls::set_movabl(\"place\",$data);\nMovabls_Permissions::set_movabl_permissions(\"place\",$GUID,array(array(\'id\'=>1,\'read\'=>1,\'write\'=>1,\'execute\'=>1)));\n\nif ($GUID !=\"\") return date(\"h:i:s A\").$GUID;\nelse return \"error in post_place\";\n'),(87,'fnc000000014lyqqh8khw7l30vclu860','','if( isset( $GLOBALS->_POST[\'password\'] ) && isset( $GLOBALS->_POST[\'email\'] ) ) {\n\n$create_user = Movabls_Users::create($GLOBALS->_POST[\'password\'], Array(\'email\'=>$GLOBALS->_POST[\'email\']) );\n\n\nreturn $create_user;\n\n}else{\nreturn \"FALSE\";\n}'),(88,'fnc000000014lyqr1polu0a35j52dkp8','','if (isset($GLOBALS->_POST[\'name\']) && isset($GLOBALS->_POST[\'password\']) ) {\n	if ( Movabls_Users::login(\'name\', $GLOBALS->_POST[\'name\'] , $GLOBALS->_POST[\'password\'] ))\n	return \"TRUE\";\n	else \n	return \"FALSE\";\n}else{\nreturn \"FALSE\";\n}\n'),(92,'fnc000000014m06jtvjxs6oazcz8sc0i','','return \"packages\";'),(93,'fnc000000014m06juwo1wadqxwwlwvh3','','return \"users\";'),(94,'fnc000000014m06k0b6t0b01tykdgrhg','','return \"groups\";'),(95,'fnc000000014m1gofu0lae0xbfhfo799','','if ($GLOBALS->_POST[\'name\']!=\"\"){\n\n$create_group = Movabls_Users::create_group($GLOBALS->_POST[\'name\'], $GLOBALS->_POST[\'session_term\'] );\n\n\nreturn $create_group;\n\n}else{\n\nreturn \"FALSE\";\n\n}'),(96,'fnc00000001glqzaqhhpzqshz7n7wxq','','if ($GLOBALS->_POST[\'name\']!=\"\"){\n\n$create_package=Movabls::set_movabl(\"package\",Array(\"meta\"=>Array(\"label\"=>$GLOBALS->_POST[\'name\'])) );\n\nMovabls_Permissions::set_movabl_permissions(\"package\",$create_package,array(array(\'id\'=>1,\'read\'=>1,\'write\'=>1,\'execute\'=>1)));\n\nreturn $create_package;\n\n}else{\n\nreturn \"FALSE\";\n\n}');
/*!40000 ALTER TABLE `mvs_functions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mvs_group_memberships`
--

DROP TABLE IF EXISTS `mvs_group_memberships`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mvs_group_memberships` (
  `user_id` int(11) NOT NULL,
  `group_id` int(11) NOT NULL,
  PRIMARY KEY (`user_id`,`group_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mvs_group_memberships`
--

LOCK TABLES `mvs_group_memberships` WRITE;
/*!40000 ALTER TABLE `mvs_group_memberships` DISABLE KEYS */;
INSERT INTO `mvs_group_memberships` VALUES (1,1),(6,1),(6,10);
/*!40000 ALTER TABLE `mvs_group_memberships` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mvs_groups`
--

DROP TABLE IF EXISTS `mvs_groups`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mvs_groups` (
  `group_id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) NOT NULL,
  `session_term` int(11) DEFAULT NULL,
  PRIMARY KEY (`group_id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mvs_groups`
--

LOCK TABLES `mvs_groups` WRITE;
/*!40000 ALTER TABLE `mvs_groups` DISABLE KEYS */;
INSERT INTO `mvs_groups` VALUES (1,'Administrators',2629743),(10,'Light Co.',2629743);
/*!40000 ALTER TABLE `mvs_groups` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mvs_interfaces`
--

DROP TABLE IF EXISTS `mvs_interfaces`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mvs_interfaces` (
  `interface_id` int(11) NOT NULL AUTO_INCREMENT,
  `interface_GUID` varchar(32) NOT NULL,
  `content` text NOT NULL,
  PRIMARY KEY (`interface_id`),
  UNIQUE KEY `interface_GUID` (`interface_GUID`)
) ENGINE=InnoDB AUTO_INCREMENT=96 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mvs_interfaces`
--

LOCK TABLES `mvs_interfaces` WRITE;
/*!40000 ALTER TABLE `mvs_interfaces` DISABLE KEYS */;
INSERT INTO `mvs_interfaces` VALUES (7,'place','{\r\n\"Place\":\r\n	{\r\n	\"expression\":\"Movabls::Get_Place();\"\r\n	}\r\n}'),(9,'media','{\"MediaLookup\":{\"expression\":\"Movabls::get_movabl(\'media\', substr($GLOBALS->_SERVER[\'REQUEST_URI\'],11) )\"},\"Media\":{\"movabl_GUID\":\"media_mime\",\"movabl_type\":\"function\",\"tags\":{\"RawMedia\":{\"expression\":\"$MediaLookup\"}}},\"MediaInputs\":{\"movabl_GUID\":\"encode_inputs\",\"movabl_type\":\"function\",\"tags\":{\"Movabl\":{\"expression\":\"$MediaLookup\"}}},\"SiteName\":{\"expression\":\"$GLOBALS->_SERVER[\'HTTP_HOST\'];\"},\"MimeToCPType\":{\"expression\":\"Array(\'text\\/html\'=>\'html\',\'text\\/javascript\'=>\'javascript\',\'text\\/sql\'=>\'sql\',\'text\\/css\'=>\'css\',\'text\\/plain\'=>\'text\');\"},\"GUID\":{\"expression\":\"substr($GLOBALS->_SERVER[\'REQUEST_URI\'],11) \"},\"Base64Encoded\":{\"expression\":\"base64_encode($MediaLookup[\\\"content\\\"])\"},\"package_ar\":{\"expression\":\"Movabls::get_packages()\"},\"interface_ar\":{\"expression\":\"Movabls::get_index();\"},\"group_ar\":{\"expression\":\"Movabls_Users::get_groups()\"}}'),(10,'function','{\"Function\":{\"expression\":\"Movabls::get_movabl(\'function\', substr($GLOBALS->_SERVER[\'REQUEST_URI\'],14) );\"},\"SiteName\":{\"expression\":\"$GLOBALS->_SERVER[\'HTTP_HOST\'];\"},\"Inputs\":{\"movabl_GUID\":\"encode_inputs\",\"movabl_type\":\"function\",\"tags\":{\"Movabl\":{\"expression\":\"$Function\"}}},\"GUID\":{\"expression\":\"substr($GLOBALS->_SERVER[\'REQUEST_URI\'],14) \"},\"package_ar\":{\"expression\":\"Movabls::get_packages()\"}}'),(11,'interface','{\"Interface\":{\"expression\":\"Movabls::get_movabl(\'interface\', substr($GLOBALS->_SERVER[\'REQUEST_URI\'],15) );\"},\"JSON\":{\"movabl_GUID\":\"mapinterface\",\"movabl_type\":\"function\",\"tags\":{\"Interface_Input\":{\"expression\":\"$Interface;\"}}},\"SiteName\":{\"expression\":\"$GLOBALS->_SERVER[\'HTTP_HOST\'];\"},\"GUID\":{\"expression\":\"substr($GLOBALS->_SERVER[\'REQUEST_URI\'],15) \"}}'),(16,'Set_Media','{\"SetMedia\":{\"movabl_GUID\":\"post_media\",\"movabl_type\":\"function\"}}'),(17,'Set_Interface','{\"Set_Interface\":{\"movabl_type\":\"function\",\"movabl_GUID\":\"post_interface\"}}'),(18,'Set_Function','{\"Set_Function\":{\"movabl_type\":\"function\",\"movabl_GUID\":\"post_function\"}}'),(62,'int00000001glh2dr7pnbpcy78qg6rl','{\"create_user\":{\"movabl_type\":\"function\",\"movabl_GUID\":\"fnc000000014lyqqh8khw7l30vclu860\"},\"email\":{\"expression\":\"$GLOBALS->_POST[\'email\']\"},\"password\":{\"expression\":\"$GLOBALS->_POST[\'password\']\"}}'),(63,'int000000014lyqqzrupsywpmwe8qbv4','{\"sign_in\":{\"movabl_type\":\"function\",\"movabl_GUID\":\"fnc000000014lyqr1polu0a35j52dkp8\"},\"email\":{\"expression\":\"$GLOBALS->_POST[\'email\']\"},\"password\":{\"expression\":\"$GLOBALS->_POST[\'password\']\"},\"referrer\":{\"expression\":\"$GLOBALS->_PLACE[\'destination\']\"},\"host\":{\"expression\":\"$GLOBALS->_SERVER[\'HTTP_HOST\']\"}}'),(65,'int000000014m06k27mpbe52oinx50wp','{\"get_places\":{\"expression\":\"Movabls::get_index()\"}}'),(66,'int000000014m06k2yy168hl0rowyh7b','{\"get_users\":{\"expression\":\"Movabls_Users::get_users()\"}}'),(68,'int00000001glm97mulr65ec3esadx7','{\"get_packages\":{\"expression\":\"Movabls::get_packages()\"}}'),(70,'int000000014m1gnlhchxxo0xfz4hb06','{\"group_name\":{\"expression\":\"$GLOBALS->_POST[\'name\']\"},\"create_group\":{\"movabl_type\":\"function\",\"movabl_GUID\":\"fnc000000014m1gofu0lae0xbfhfo799\"}}'),(71,'int000000014m1hsqj0lqf7uh3mqszmf','{\"create_package\":{\"movabl_type\":\"function\",\"movabl_GUID\":\"fnc00000001glqzaqhhpzqshz7n7wxq\"}}'),(95,'launchpad2','{\"GetIndex\":{\"expression\":\"Movabls::get_index();\"},\"SiteName\":{\"expression\":\"$GLOBALS->_SERVER[\'HTTP_HOST\']\"},\"Media\":{\"expression\":\"$GetIndex[\'media\']\"},\"Functions\":{\"expression\":\"$GetIndex[\'functions\']\"},\"Interfaces\":{\"expression\":\"$GetIndex[\'interfaces\']\"},\"GetPackages\":{\"expression\":\"Movabls::get_packages();\"}}');
/*!40000 ALTER TABLE `mvs_interfaces` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mvs_media`
--

DROP TABLE IF EXISTS `mvs_media`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mvs_media` (
  `media_id` int(11) NOT NULL AUTO_INCREMENT,
  `media_GUID` varchar(32) NOT NULL,
  `mimetype` varchar(255) NOT NULL,
  `inputs` text NOT NULL,
  `content` longblob NOT NULL,
  PRIMARY KEY (`media_id`),
  UNIQUE KEY `media_GUID` (`media_GUID`)
) ENGINE=InnoDB AUTO_INCREMENT=622 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mvs_media`
--

LOCK TABLES `mvs_media` WRITE;
/*!40000 ALTER TABLE `mvs_media` DISABLE KEYS */;
INSERT INTO `mvs_media` VALUES (1,'TEST_MEDIA','text/html','[\"subdomain\",\"mvs_server\",\"mvs_user\",\"latest\"]','<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n	<link href=\'http://fonts.googleapis.com/css?family=Josefin+Slab:400,700,400italic\' rel=\'stylesheet\' type=\'text/css\'>\n	<meta charset=\"utf-8\" />\n	<title>Light Company!</title>\n\n<style>\nbody{ font-family: \'Josefin Slab\', serif; padding:20px; display:block; height:100%; width:100%; }\n.logo{\nfont-family: \'Josefin Slab\', serif;\nfont-style: normal;\nfont-weight: 800;\n\ntext-transform: none;\ntext-decoration: none;\nletter-spacing: -0.04em;\nword-spacing: 0em;\nline-height: 1.4;\n}\n\nh1 {font-size: 32px;}\nh4 {font-size: 22px; }\n\n.cta, .chzn-choices input, .chzn-container-multi .chzn-choices .search-field .default, .chzn-container-multi  ul.chzn-choices{\ncolor:#000000;\nbackground:#F9FFC7;\nfont-family: \'Josefin Slab\', serif;\nfont-style: italic;\ntext-transform: none;\nletter-spacing: 0em;\nword-spacing: 0em;\nline-height: 1.4;\npadding:0 .6em 0 .2em;\nmargin:0 -.2em 0 0;\n}\n\n.block {display:block; height:300px; width:300px; border:solid 1px gainsboro;}\n.cta:hover{text-decoration:underline; color:black; background:white;}\n.chzn-container {margin-top:30px; vertical-align:baseline; }\n\n.subhead, .chzn-container, .chzn-container-multi .chzn-choices .search-field .default {font-size: 32px;}\n\n#sign_in{position:fixed; right:20px; top:20px; font-size:18px; font-weight:600;}\n\n.chzn-container-multi  ul.chzn-choices {border:0;} \nspan#toolbar {float:left; wisdth:400px; heisght:30px; vertical-align:middle;bsackground:purple; }\nh4.logo {padding:0; margin:0; wisdth:100px; hesight:30px; vertical-align:baseline; bsdackground:pink; clear:none;float:left;}\n#user {heigsht:30px; widsth:1000px;}\n\n</style>\n<script type=\"text/javascript\">\n\n  var _gaq = _gaq || [];\n  _gaq.push([\'_setAccount\', \'UA-20413278-1\']);\n  _gaq.push([\'_trackPageview\']);\n\n  (function() {\n    var ga = document.createElement(\'script\'); ga.type = \'text/javascript\'; ga.async = true;\n    ga.src = (\'https:\' == document.location.protocol ? \'https://ssl\' : \'http://www\') + \'.google-analytics.com/ga.js\';\n    var s = document.getElementsByTagName(\'script\')[0]; s.parentNode.insertBefore(ga, s);\n  })();\n\n</script>\n</head>\n\n<body>\n{{if mvs_user[\"user_GUID\"] != \"\" }}\n<div id=\"user\">\n<h4 class=\"logo\">Light Co.</h4>\n</div>\n{{else}}\n<h1 class=\"logo\">Light Company.</h1>\n\n<span class=\"subhead\">\nShare  <span class=\"cta\" >things</span>\nwith <span class=\"cta\">someone</span> interesting.\n</span>\n\n{{endif}}\n\n\n</body>\n</html>'),(14,'place','text/html','[\"Place\"]','<html>\n\n<script src=\"http://api.movabls.com///~/base.js\"></script> \n\n\n<style>\n\nbody{font-family:sans-serif;}\na{text-decoration:none;}\n\n\n#content{display:block; position:absolute; top:10%; left:20px; width:60%; height:70%; overflow:auto;}\n.APIPlaces_Pattern{display:block; position:absolute; top:10%; left:62%; width:38%; height:85%;overflow:auto;}\n\n\n</style>\n<body>\n{{Place[\"label\"]}}\n<h3>{{Place[\"url\"]}} ({{Place[\"place_GUID\"]}})</h3>\n\nmedia: <input type=\"text\" value=\"{{Place[\"media_GUID\"]}}\"><br>\ninterface: <input type=\"text\" value=\"{{Place[\"interface_GUID\"]}}\"><br>\n\n</body>\n</html>'),(18,'function','text/html','[\"Function\",\"SiteName\",\"Inputs\",\"GUID\",\"package_ar\"]',' <!DOCTYPE html> \n<title>{{Function[\"meta\"][\"label\"]}}</title>\n<meta charset=utf-8> \n<script>\nrequestInProgress=0\nresponseDiv=\"status\";\n</script>\n<link rel=\"stylesheet\" href=\"/codemirror/lib/codemirror.css\">\n<link rel=\"stylesheet\" href=\"/codemirror/theme/elegant.css\">\n<link rel=\"stylesheet\" href=\"/codemirror/util/dialog.css\">\n\n<script src=\"/codemirror/lib/codemirror.js\"></script>\n<script src=\"/codemirror/util/search.js\"></script>\n<script src=\"/codemirror/util/searchcursor.js\"></script>\n<script src=\"/codemirror/util/dialog.js\"></script>\n\n<script src=\"/codemirror/mode/php.js\"></script>\n<script src=\"/codemirror/mode/javascript.js\"></script>\n<script src=\"/codemirror/mode/clike.js\"></script>\n<script src=\"/codemirror/mode/htmlmixed.js\"></script>\n<script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\"></script>\n\n<script src=\"http://{{SiteName}}///~/base.js\"></script> \n\n<style>\n        .CodeMirror {border:solid 1px gainsboro; background:white;}\n        .CodeMirror-fullscreen, .fullscreen {\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 90%;\n            z-index: 9999;\n            margin: 0;\n            padding: 0;\n            border: 0px solid #BBBBBB;\n            opacity: 1;\nbackground:white;\n        }\n.activeline {background: #e8f2ff !important;}\n  button#fs {position:absolute; top:2px; right:10px; z-index:100000;}\n\n</style>\n<body>\n\n  <a href=\"http://{{SiteName}}///\">///</a>\n\n{{if GUID = \"new\"}}\n<h3>Name Your Function</h3>\n\n<form id=\"createUnitFormasdf\" name=\"createUnitFormasdf\">\n<textarea name=\"label\" id=\"label\" >{{Function[\"meta\"][\"label\"]}}</textarea><a href=\"javascript:void(0);\" onclick=\"doRequest(\'http://{{SiteName}}///~/Set/Function/{{Function[\"function_GUID\"]}}\',\'statusFunc\',\'createUnitFormasdf\',\'\')\"  >create</a> \n<br>\n<select name=\"package_id\">\n<option value=\"\">select package</option>\n<option value=\"\"></option>\n{{for package_ar as package}}\n<option value=\"{{package[\"package_GUID\"]}}\">{{package[\"meta\"][\"label\"]}}</option>\n{{endfor}}\n</select>   OR new: <input type=\"text\" name=\"new_package\">\n<br>\n\n<textarea name=\"inputs\" id=\"inputs\" style=\"display:none\">{{Inputs}}</textarea><br>\n<textarea name=\"GUID\" id=\"GUID\" style=\"display:none\" >{{Function[\"function_GUID\"]}}</textarea>\n<textarea name=\"content\" id=\"content\" style=\"display:none\">\n{{Function[\"content\"]}}\n</textarea>\n<span id=\"statusFunc\"></span>\n\n</form>\n{{endif}}\n  \n{{if GUID != \"new\"}}\n\n<h3>{{Function[\"meta\"][\"label\"]}} <a href=\"javascript:void(0);\" onclick=\"seek(\'label\').display=\'block\'\" class=\'edit\'>edit label</a></h3>\n<span id=\"guid\">{{GUID}}</span>\n<form id=\"createUnitForm\" name=\"createUnitForm\">\n<textarea name=\"GUID\" id=\"GUID\" style=\"display:none\">{{Function[\"function_GUID\"]}}</textarea>\n<textarea name=\"label\" id=\"label\" style=\"display:none;\" >{{Function[\"meta\"][\"label\"]}}</textarea><br>\n\n<textarea name=\"inputs\" id=\"inputs\" >{{Inputs}}</textarea><br><br>\n<textarea name=\"content\" id=\"content\"  wrap=\"off\" style=\"width:700px;height:300px;\" >\n{{Function[\"content\"]}}\n</textarea>\n\n  <br>\n<span id=\"status\"></span>\n<a href=\"javascript:void(0);\"  onclick=\"seek(\'content\',1).value = editor.getValue(); doRequest(\'http://{{SiteName}}///~/Set/Function/{{Function[\"function_GUID\"]}}\',\'status\',\'createUnitForm\',\'\'); \" id=\"cta\" >save</a> \n\n</form>\n\n\n <script>\n    var editor = CodeMirror.fromTextArea(document.getElementById(\"content\"), {\n        lineNumbers: true,\n        mode:\"text/x-php\",\n            matchBrackets: true,\n\n        extraKeys: {\n				\"Ctrl-S\": function(){\n				seek(\'content\',1).value = editor.getValue();\n				doRequest(\'http://{{SiteName}}///~/Set/Function/{{Function[\"function_GUID\"]}}\',\'status\',\'createUnitForm\',\'\');\n				}\n		},\n		onKeyEvent: function(i, e) {\n          // Hook into F11\n          if ((e.keyCode == 122 || e.keyCode == 27) && e.type == \'keydown\') {\n     //e.stop();\n            return toggleFullscreenEditing();\n          }\n        },\n    onCursorActivity: function() {\n    editor.setLineClass(hlLine, null, null);\n    hlLine = editor.setLineClass(editor.getCursor().line, null, \"activeline\");\n  }\n});\nvar hlLine = editor.setLineClass(0, \"activeline\");\n   \n\n   \n   document.cancelFullScreen = document.webkitCancelFullScreen ||\n                            document.mozCancelFullScreen;\n   \nfunction toggleFullscreenEditing()\n    {\n     document.documentElement.webkitRequestFullScreen(1);\n        var editorDiv = $(\'.CodeMirror-scroll\');\n        if (!editorDiv.hasClass(\'fullscreen\')) {\n            toggleFullscreenEditing.beforeFullscreen = { height: editorDiv.height(), width: editorDiv.width() }\n            editorDiv.addClass(\'fullscreen\');\n            editorDiv.height(\'100%\');\n            editorDiv.width(\'100%\');\n            editor.refresh();\n        }\n        else {\n          document.cancelFullScreen();\n            editorDiv.removeClass(\'fullscreen\');\n            editorDiv.height(400);\n            editorDiv.width(toggleFullscreenEditing.beforeFullscreen.width);\n            editor.refresh();\n        }\n    }\n                                         \n \n</script>\n   <button id=\"fs\" onclick=\"toggleFullscreenEditing()\">fullscreen</button>\n{{endif}}\n\n\n\n</body>\n</html>\n'),(29,'basejs','text/javascript','','function seek(ele,type){\nif (ele=document.getElementById(ele)) return (type) ? ele:ele.style; else return false;}\n\nfunction stateChange(a){\n	if (xmlhttp.readyState==4){\n		 if (xmlhttp.status==200){\n			response=xmlhttp.responseText;\n			scriptstartpos=response.indexOf(\"script>\");\n			scriptendpos=response.indexOf(\"/script>\")\n			loadscript=\"\";\n//alert(response);\n			if (scriptendpos>0)\n				loadscript=response.substring(scriptstartpos+7, scriptendpos-1);\n\n			stylestartpos=response.indexOf(\"style>\");\n			styleendpos=response.indexOf(\"/style>\")\n\n			loadstyle=\"\";\n			if (styleendpos>0)\n				loadstyle=response.substring(stylestartpos+7, styleendpos-1);\n\n			var head = document.getElementsByTagName(\"head\")[0];\n			if (loadscript !=\"\"){\n				script = document.createElement(\'script\');\n				script.id = \'jstem\';\n				script.type = \'text/javascript\';\n				script.text= loadscript;\n				head.appendChild(script);\n			}\n			\n			if (loadstyle !=\"\"){\n				var style = document.createElement(\"style\");\n				style.setAttribute(\"type\", \"text/css\");\n				if(style.styleSheet){// IE\n					style.styleSheet.cssText = loadstyle ;\n				} else {\n					var cssText = document.createTextNode(loadstyle);\n					style.appendChild(cssText);\n				}\n   			head.appendChild(style);\n			}	\n			if(responseDiv.substring(0,5)==\"form_\") seek(responseDiv,1).value=response;	\n			else if(responseDiv!=\"\") seek(responseDiv,1).innerHTML=response;	\n			requestInProgress=0;\n		}  else  {\n			requestInProgress=2;\n	 	} \n	} \n}\n	\n\n\n\nfunction doRequest(URL,destDiv,formId,parentId){\n	if(destDiv==\"\")responseDiv=destDiv;\n	var boundaryString = \'AaB03x\';\n	var boundary = \'--\' + boundaryString;\n\n	sendStr = [\n	boundary\n	].join(\'\\r\\n\');\n\n		\n	if ((formId!=undefined)&&(formId!=\"\")){\n\n		if (parentId!=\"\") formChildrenAr=seek(parentId,1).contentWindow.document.getElementById(formId).childNodes;\n		else formChildrenAr=seek(formId,1).childNodes;\n\n		strCnt=0;\n		for(j=0; j<formChildrenAr.length; j++) {\n\n			if ((formChildrenAr[j].name!=undefined)&&(formChildrenAr[j].name!=\"\")) {\n//if ((formChildrenAr[j].type !=\"radio\" )&&(formChildrenAr[j].checked !=0)) {\n\n					strCnt++;\n					sendStr+=\'\\r\\n\';\n					sendStr+=\'Content-Disposition: form-data; name=\"\'+formChildrenAr[j].name+\'\"\';\n					sendStr+=\'\\r\\n\';\n					sendStr+=\'\\r\\n\';\n					sendStr+=formChildrenAr[j].value;\n					sendStr+=\'\\r\\n\';\n					sendStr+=boundary;\n\n				}\n//			}\n		}\n\n\n	}\n//alert(sendStr);\n	if (requestInProgress==1) {\n		setTimeout(\"doRequest(\'\"+URL+\"\',\'\"+destDiv+\"\',\'\"+formId+\"\',\'\"+id+\"\',\'\"+parentId+\"\')\", 10);\n		return false;\n	}\n		\n	if (window.XMLHttpRequest) {\n\n		xmlhttp=new XMLHttpRequest()\n		if (xmlhttp){\n			xmlhttp.onreadystatechange=stateChange\n			requestInProgress=1;\n			xmlhttp.open(\"POST\",URL,true)\n			//alert(xmlhttp);\n			xmlhttp.setRequestHeader(\'Content-Type\',\'multipart/form-data; charset=UTF-8; boundary=\' + boundaryString);\n			//xmlhttp.setRequestHeader(\"Content-length\", sendStr.length);\n			//xmlhttp.setRequestHeader(\"Connection\", \"close\");\n			\n			xmlhttp.send(sendStr+\"--\\r\\n\");\n		}\n		\n	}else if (window.ActiveXObject) {\n		xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\")\n		if (xmlhttp){\n			xmlhttp.onreadystatechange=stateChange\n			xmlhttp.open(\"POST\",URL,true)\n\n			xmlhttp.setRequestHeader(\'Content-Type\',\'multipart/form-data; charset=UTF-8; boundary=\' + boundaryString);\n			//xmlhttp.setRequestHeader(\"Content-length\", sendStr.length);\n			//xmlhttp.setRequestHeader(\"Connection\", \"close\");\n\n			xmlhttp.send(sendStr+\"--\\r\\n\");\n\n		}\n	}\n}\n	 \n	 \n	 \nfunction ajaxSubmitForm(pass1,pass2,parentId){\nvar d = new Date();\nvar t = d.getTime();\ntim=t+\"\";\ntimestamp=tim.substr(0,6);\n	if (pass1!=\"update\"){\n		doRequest(\"ajaxSubmission/\"+pass1+\"/\"+pass2, pass1+pass2+\"Status\",pass1+pass2+\"Form\",parentId)\n	}else{\n		doRequest(\"update/\"+pass2, \"globalstatus\",pass1+pass2+\"Form\",parentId)\n	}\n}\n\nfunction createCookie(name,value,days) {\n	if (days) {\n		var date = new Date();\n		date.setTime(date.getTime()+(days*24*60*60*1000));\n		var expires = \"; expires=\"+date.toGMTString();\n	}\n	else var expires = \"\";\n	document.cookie = name+\"=\"+value+expires+\"; path=/\";\n}\n\nfunction readCookie(name) {\n	var nameEQ = name + \"=\";\n	var ca = document.cookie.split(\';\');\n	for(var i=0;i < ca.length;i++) {\n		var c = ca[i];\n		while (c.charAt(0)==\' \') c = c.substring(1,c.length);\n		if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);\n	}\n	return null;\n}\n\nfunction eraseCookie(name) {\n	createCookie(name,\"\",-1);\n}'),(37,'Set_Media','text/plain','[\"SetMedia\"]',' {{SetMedia}}'),(39,'Set_Function','text/plain','[\"Set_Function\"]','{{Set_Function}}'),(40,'Set_Interface','text/plain','[\"Set_Interface\"]','{{Set_Interface}}'),(187,'mda000000014h5a7m1l8osd0tsw41flr','text/html','[\"Interface\",\"SiteName\",\"JSON_Content\",\"JSON\",\"GUID\"]',' <!DOCTYPE html> \n<title>{{Interface[\"meta\"][\"label\"]}}</title>\n<meta charset=utf-8> \n<script>\nrequestInProgress=0\nresponseDiv=\"status\";\n</script>\n<link rel=\"stylesheet\" href=\"/codemirror/lib/codemirror.css\">\n<link rel=\"stylesheet\" href=\"/codemirror/theme/elegant.css\">\n<link rel=\"stylesheet\" href=\"/codemirror/util/dialog.css\">\n\n<script src=\"/codemirror/lib/codemirror.js\"></script>\n<script src=\"/codemirror/util/search.js\"></script>\n<script src=\"/codemirror/util/searchcursor.js\"></script>\n<script src=\"/codemirror/util/dialog.js\"></script>\n\n<script src=\"/codemirror/mode/xml.js\"></script>\n<script src=\"/codemirror/mode/javascript.js\"></script>\n<script src=\"/codemirror/mode/css.js\"></script>\n<script src=\"/codemirror/mode/htmlmixed.js\"></script>\n<script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\"></script>\n\n<script src=\"http://{{SiteName}}///~/base.js\"></script> \n\n<style>\n        .CodeMirror {border:solid 1px gainsboro; background:white;}\n        .CodeMirror-fullscreen, .fullscreen {\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 90%;\n            z-index: 9999;\n            margin: 0;\n            padding: 0;\n            border: 0px solid #BBBBBB;\n            opacity: 1;\nbackground:white;\n        }\n.activeline {background: #e8f2ff !important;}\n  button#fs {position:absolute; top:2px; right:10px; z-index:100000;}\n\n</style>\n<body>\n\n  <a href=\"http://{{SiteName}}///\">///</a>\n\n\n  \n  \n  {{if GUID = \"new\"}}\n\n<h3>Name Your Interface</h3>\n<span id=\"statusInt\"></span>\n<form id=\"createUnitFormInterface\" name=\"createUnitFormInterface\">\n<textarea name=\"GUID\" id=\"GUID\" style=\"display:none;\">{{Interface[\"interface_GUID\"]}}</textarea>\n<textarea name=\"label\" id=\"label\" >{{Interface[\"meta\"][\"label\"]}}</textarea> <a href=\"javascript:void(0);\" onclick=\"doRequest(\'http://{{SiteName}}///~/Set/Interface/{{Interface[\"interface_GUID\"]}}\',\'statusInt\',\'createUnitFormInterface\',\'\');\">Create</a>\n<textarea name=\"json\" id=\"json\" >{{JSON}}</textarea>\n</form>\n\n\n{{endif}}\n\n{{if GUID != \"new\"}}\n<h3>{{Interface[\"meta\"][\"label\"]}}</h3>\n<span id=\"statusInt\"></span>\n\n\n\n<form id=\"createUnitFormInterface\" name=\"createUnitFormInterface\">\n\n<textarea name=\"GUID\" id=\"GUID\" style=\"display:none;\">{{Interface[\"interface_GUID\"]}}</textarea>\n<textarea name=\"label\" id=\"label\" >{{Interface[\"meta\"][\"label\"]}}</textarea>({{Interface[\"interface_GUID\"]}}) \n<textarea name=\"json\" id=\"json\" id=\"json\">{{JSON}}</textarea>\n  \n  <a href=\"javascript:void(0);\"  onclick=\"seek(\'json\',1).value = editor.getValue(); doRequest(\'http://{{SiteName}}///~/Set/Interface/{{Interface[\"interface_GUID\"]}}\',\'statusInt\',\'createUnitFormInterface\',\'\'); \" id=\"cta\" >save</a> \n\n</form>\n\n\n <script>\n    var editor = CodeMirror.fromTextArea(document.getElementById(\"json\"), {\n        lineNumbers: true,\n        mode:\"application/json\",\n      matchBrackets: true,\n        extraKeys: {\n				\"Ctrl-S\": function(){\n				seek(\'json\',1).value = editor.getValue();\n				doRequest(\'http://{{SiteName}}///~/Set/Interface/{{Interface[\"interface_GUID\"]}}\',\'statusInt\',\'createUnitFormInterface\',\'\');\n				}\n		},\n		onKeyEvent: function(i, e) {\n          // Hook into F11\n          if ((e.keyCode == 122 || e.keyCode == 27) && e.type == \'keydown\') {\n     //e.stop();\n            return toggleFullscreenEditing();\n          }\n        },\n    onCursorActivity: function() {\n    editor.setLineClass(hlLine, null, null);\n    hlLine = editor.setLineClass(editor.getCursor().line, null, \"activeline\");\n  }\n});\nvar hlLine = editor.setLineClass(0, \"activeline\");\n   \n   \n   document.cancelFullScreen = document.webkitCancelFullScreen ||\n                            document.mozCancelFullScreen;\n   \nfunction toggleFullscreenEditing()\n    {\n     document.documentElement.webkitRequestFullScreen(1);\n        var editorDiv = $(\'.CodeMirror-scroll\');\n        if (!editorDiv.hasClass(\'fullscreen\')) {\n            toggleFullscreenEditing.beforeFullscreen = { height: editorDiv.height(), width: editorDiv.width() }\n            editorDiv.addClass(\'fullscreen\');\n            editorDiv.height(\'100%\');\n            editorDiv.width(\'100%\');\n            editor.refresh();\n        }\n        else {\n          document.cancelFullScreen();\n            editorDiv.removeClass(\'fullscreen\');\n            editorDiv.height(400);\n            editorDiv.width(toggleFullscreenEditing.beforeFullscreen.width);\n            editor.refresh();\n        }\n    }\n                                         \n</script>\n   <button id=\"fs\" onclick=\"toggleFullscreenEditing()\">fullscreen</button>\n{{endif}}\n\n\n\n</body>\n</html>\n\n'),(508,'mda000000014lyqp22tpp8k25mh8wgi7','text/html','[\"create_user\",\"email\",\"password\"]','{{if create_user == \"FALSE\"}}\n\n\n\n<form method=\"POST\">\n	<input type=\"text\" name=\"email\" /> <br/>\n	<input type=\"password\" name=\"password\" />\n	<input type=\"submit\" value=\"Welcome!\" />\n</form>\n\n{{else}}\n\n{{create_user}}\n\n\n{{endif}}'),(509,'mda000000014lyqras857620egeb2nof','text/html','[\"sign_in\",\"email\",\"password\",\"referrer\",\"host\"]','{{if sign_in = \"TRUE\" }}\n\n<script>\ndocument.location=\"http://{{host}}/{{referrer}}\";\n</script>\n\n{{else}}\n <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n	<meta charset=\"utf-8\" />\n	<title>///</title>\n	<link rel=\"stylesheet\" type=\"text/css\" href=\"/color/css\" />\n	<style>\nform {\nfont-family:Garamond, serif; font-size:18px; color:#363636;\nposition:relative; top: 40px; left:40px; clear:both; margin:auto; width:900px; background:white; height:auto;}\ninput#signin { font-size:18px; line-height:42px; text-decoration:none; border-radius: 4px;  -moz-border-radius: 4px;   border:solid 1px gainsboro; height:60px; width:100px; text-align:right; }\n</style>\n<body>\n\n<form method=\"POST\">\nhello,<br/><br/>\n	<input type=\"text\" name=\"name\" /> <br/>\n	<input type=\"password\" name=\"password\" /> <br/>\n	<input type=\"hidden\" name=\"referrer\" value=\"{{referrer}}\" /><br/>\n	<input type=\"submit\" id=\"signin\" value=\"Sign In\" />\n</form>\n</body>\n</html>\n{{endif}}\n'),(511,'mda000000014m06kahjp4o5a325mllkx','text/html','[\"get_places\",\"mvs_server\"]','<pre>\n{{for get_places[\"places\"] as place}}\n\n<a href=\"http://{{mvs_server[\"SERVER_NAME\"]}}{{place[\"url\"]}}\" target=\"_new\">{{place[\"url\"]}}</a> {{place[\"media_GUID\"]}}  {{place[\"interface_GUID\"]}}  {{place[\"inputs\"]}}\n\n{{endfor}}\n\n\n</pre>'),(512,'mda000000014m06kdv5hohtdbnmy1ha4','text/html','[\"get_users\",\"mvs_server\"]','<pre>\n\n<a href=\"http://{{mvs_server[\"SERVER_NAME\"]}}///~/user/create\">new</a>!\n\n{{for get_users as user }}\n<b>{{user[\"email\"]}}</b>\n{{for user as groups}}\n{{if groups != user[\"email\"]}}\n	{{groups[\"name\"]}}\n\n{{endif}}\n{{endfor}}\n\n{{endfor}}\n</pre>'),(513,'mda000000014m06kgzylc1gi49c513lx','text/html','[\"get_packages\",\"mvs_server\"]','<pre>\n\n<a href=\"http://{{mvs_server[\"SERVER_NAME\"]}}///~/package/create\">new</a>!\n\n{{for get_packages as package}}\n{{package[\"meta\"][\"label\"]}}\n\n{{endfor}}\n</pre>'),(516,'mda000000014m1gq71v5rm45y8czvbt5','text/html','[\"create_group\",\"group_name\"]','{{if create_group == \"FALSE\"}}\n\n<form method=\"POST\">\n	<input type=\"text\" name=\"name\" /> <br/>\n	<input type=\"text\" name=\"session_term\" value=\"2629743\" /> <br/>\n	<input type=\"submit\" value=\"Org!\" />\n</form>\n\n{{else}}\n\n{{create_group}}\n\n{{endif}}'),(517,'mda000000011nrwbxht6m4772q81ali','text/html','[\"create_package\",\"mvs_server\"]','{{if create_package == \"FALSE\"}}\n\n<form method=\"POST\">\n	<input type=\"text\" name=\"name\" /> <br/>\n	<input type=\"submit\" value=\"Package!\" />\n</form>\n\n{{else}}\n\n\n{{create_package}}\n<br/><br/>\n\n<a href=\"http://{{mvs_server[\"SERVER_NAME\"]}}///~/packages\">packages</a> <\n\n\n{{endif}}'),(603,'mda000000014qocmi1dw4lpwq5lzmnbq','text/html','[\"MediaLookup\",\"Media\",\"SiteName\",\"MimeToCPType\",\"MediaInputs\",\"GUID\",\"Base64Encoded\",\"package_ar\",\"interface_ar\",\"group_ar\"]',' <!DOCTYPE html> \n<title>{{Media[\"meta\"][\"label\"]}}</title>\n<meta charset=utf-8> \n<script>\nrequestInProgress=0\nresponseDiv=\"status\";\n</script>\n<link rel=\"stylesheet\" href=\"/codemirror/lib/codemirror.css\">\n<link rel=\"stylesheet\" href=\"/codemirror/theme/elegant.css\">\n<link rel=\"stylesheet\" href=\"/codemirror/util/dialog.css\">\n\n<script src=\"/codemirror/lib/codemirror.js\"></script>\n<script src=\"/codemirror/util/search.js\"></script>\n\n\n<script src=\"/codemirror/util/searchcursor.js\"></script>\n<script src=\"/codemirror/util/dialog.js\"></script>\n\n<script src=\"/codemirror/mode/xml.js\"></script>\n<script src=\"/codemirror/mode/javascript.js\"></script>\n<script src=\"/codemirror/mode/css.js\"></script>\n<script src=\"/codemirror/mode/htmlmixed.js\"></script>\n<script src=\"http://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\"></script>\n\n<script src=\"http://{{SiteName}}///~/base.js\"></script> \n\n<style>\n        .CodeMirror {border:solid 1px gainsboro; background:white;}\n        .CodeMirror-fullscreen, .fullscreen {\n            display: block;\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 90%;\n            z-index: 9999;\n            margin: 0;\n            padding: 0;\n            border: 0px solid #BBBBBB;\n            opacity: 1;\nbackground:white;\n        }\n.activeline {background: #e8f2ff !important;}\n  button#fs {position:absolute; top:2px; right:10px; z-index:100000;}\n\n</style>\n<body>\n\n  <a href=\"http://{{SiteName}}///\">///</a>\n  \n{{if GUID = \"new\"}}\n\n<h3>Name Your Media</h3>\n<form id=\"createUnitForm\" name=\"createUnitForm\">\n<textarea name=\"GUID\" id=\"GUID\" style=\"display:none\">{{Media[\"media_GUID\"]}}</textarea>\n<textarea name=\"label\" id=\"label\" ></textarea> <a href=\"javascript:void(0);\"  onclick=\"doRequest(\'http://{{SiteName}}///~/Set/Media/{{Media[\"media_GUID\"]}}\',\'status\',\'createUnitForm\',\'\'); \" >create</a><br>\n<textarea name=\"mimetype\" id=\"mimetype\" style=\"display:none\"></textarea><br>\n<textarea name=\"inputs\" id=\"inputs\" style=\"display:none\" ></textarea><br><br>\n<textarea name=\"content\" id=\"content\"  class=\"codepress\" wrap=\"off\"  style=\"display:none; width:70%;height:70%;\" > </textarea>\n<input type=\"hidden\" name=\"content_store\" id=\"content_store\">\noptional place url [ incl /]  <textarea name=\"place_url\" id=\"place_url\" ></textarea>  <select name=\"group_id\">\n{{for group_ar as group}}\n{{if group[\"name\"] != \"\"}}	<option value=\"{{group[\"group_id\"]}}\">{{group[\"name\"]}}</option>{{endif}}\n{{endfor}}\n</select>\n<br>\n\n<br>\n<select name=\"interface_id\">\n<option value=\"\">select interface</option>\n<option value=\"\"></option>\n{{for interface_ar[\"interfaces\"] as interface}}\n{{if interface[\"meta\"][\"label\"] != \"\"}}	<option value=\"{{interface[\"interface_GUID\"]}}\">{{interface[\"meta\"][\"label\"]}}</option>{{endif}}\n{{endfor}}\n</select>   OR new: <input type=\"text\" name=\"new_interface\">\n<br>\n\n\n\n<br>\n<select name=\"package_id\">\n<option value=\"\">select package</option>\n<option value=\"\"></option>\n{{for package_ar as package}}\n<option value=\"{{package[\"package_GUID\"]}}\">{{package[\"meta\"][\"label\"]}}</option>\n{{endfor}}\n</select>   OR new: <input type=\"text\" name=\"new_package\">\n<br>\n\n<span id=\"status\"></span>\n\n</form>\n\n{{endif}}\n\n{{if GUID = \"upload\"}}\n\n<h3>Upload Media</h3>\n<form id=\"createUnitForm\" name=\"createUnitForm\" action=\"http://{{SiteName}}///~/Set/Media/upload\" method=\"post\" enctype=\"multipart/form-data\" >\n<textarea name=\"GUID\" id=\"GUID\" style=\"display:none\">upload</textarea>\n<textarea name=\"label\" id=\"label\" ></textarea><br>\noptional place url [include /]: <textarea name=\"place_url\" id=\"place_url\" ></textarea>\n<br>\n<select name=\"interface_id\">\n<option value=\"\">select interface</option>\n<option value=\"\"></option>\n{{for interface_ar[\"interfaces\"] as interface}}\n{{if interface[\"meta\"][\"label\"] != \"\"}}	<option value=\"{{interface[\"interface_GUID\"]}}\">{{interface[\"meta\"][\"label\"]}}</option>{{endif}}\n{{endfor}}\n</select>   OR new: <input type=\"text\" name=\"new_interface\">\n<br>\n\n\n\n<br>\n<select name=\"package_id\">\n<option value=\"\">select package</option>\n<option value=\"\"></option>\n{{for package_ar as package}}\n<option value=\"{{package[\"package_GUID\"]}}\">{{package[\"meta\"][\"label\"]}}</option>\n{{endfor}}\n</select>   OR new: <input type=\"text\" name=\"new_package\">\n<br>\n<input type=\"file\" name=\"filecontent\" id=\"filecontent\" />\n<input type=\"submit\">\n<span id=\"status\"></span>\n\n</form>\n\n{{endif}}\n\n\n{{if GUID != \"new\" and GUID != \"upload\"}}\n\n<h3>{{Media[\"meta\"][\"label\"]}} <a href=\"javascript:void(0);\" onclick=\"seek(\'label\').display=\'block\'\" class=\'edit\'>edit label</a></h3>\n<span id=\"guid\">{{GUID}}</span>\n<form id=\"createUnitForm\" name=\"createUnitForm\">\n<textarea name=\"GUID\" id=\"GUID\" style=\"display:none\">{{Media[\"media_GUID\"]}}</textarea>\n<textarea name=\"label\" id=\"label\" style=\"display:none;\" >{{Media[\"meta\"][\"label\"]}}</textarea><br>\n<textarea name=\"mimetype\" id=\"mimetype\" >{{Media[\"mimetype\"]}}</textarea><br>\n\n{{if Media[\"mimetype\"] = \"image/jpeg\" or Media[\"mimetype\"] = \"image/png\" or Media[\"mimetype\"] = \"image/gif\"}}\n<img src=\"data:{{Media[\"mimetype\"]}};base64,{{Base64Encoded}}\" />\n{{else}}\n<textarea name=\"inputs\" id=\"inputs\" >{{MediaInputs}}</textarea><br><br>\n<textarea name=\"content\" id=\"content\"   wrap=\"off\" style=\"width:700px;height:300px;\" >\n{{Media[\"content\"]}}\n</textarea>\n{{endif}}\n<br>\n<span id=\"status\"></span>\n<a href=\"javascript:void(0);\"  onclick=\"seek(\'content\',1).value = editor.getValue(); doRequest(\'http://{{SiteName}}///~/Set/Media/{{Media[\"media_GUID\"]}}\',\'status\',\'createUnitForm\',\'\'); \" id=\"cta\" >save</a> \n\n</form>\n\n\n <script>\n    var editor = CodeMirror.fromTextArea(document.getElementById(\"content\"), {\n        lineNumbers: true,\n        mode:\"{{Media[\"mimetype\"]}}\",\n            matchBrackets: true,\n\n        extraKeys: {\n				\"Ctrl-S\": function(){\n				seek(\'content\',1).value = editor.getValue();\n				doRequest(\'http://{{SiteName}}///~/Set/Media/{{Media[\"media_GUID\"]}}\',\'status\',\'createUnitForm\',\'\');\n				}\n		},\n		onKeyEvent: function(i, e) {\n          // Hook into F11\n          if ((e.keyCode == 122 || e.keyCode == 27) && e.type == \'keydown\') {\n     //e.stop();\n            return toggleFullscreenEditing();\n          }\n        },\n    onCursorActivity: function() {\n    editor.setLineClass(hlLine, null, null);\n    hlLine = editor.setLineClass(editor.getCursor().line, null, \"activeline\");\n  }\n});\nvar hlLine = editor.setLineClass(0, \"activeline\");\n   \n\n   \n   document.cancelFullScreen = document.webkitCancelFullScreen ||\n                            document.mozCancelFullScreen;\n   \nfunction toggleFullscreenEditing()\n    {\n     document.documentElement.webkitRequestFullScreen(1);\n        var editorDiv = $(\'.CodeMirror-scroll\');\n        if (!editorDiv.hasClass(\'fullscreen\')) {\n            toggleFullscreenEditing.beforeFullscreen = { height: editorDiv.height(), width: editorDiv.width() }\n            editorDiv.addClass(\'fullscreen\');\n            editorDiv.height(\'100%\');\n            editorDiv.width(\'100%\');\n            editor.refresh();\n        }\n        else {\n          document.cancelFullScreen();\n            editorDiv.removeClass(\'fullscreen\');\n            editorDiv.height(400);\n            editorDiv.width(toggleFullscreenEditing.beforeFullscreen.width);\n            editor.refresh();\n        }\n    }\n                                         \n \n</script>\n   <button id=\"fs\" onclick=\"toggleFullscreenEditing()\">fullscreen</button>\n{{endif}}\n\n\n\n</body>\n</html>'),(604,'mda000000014qocp8oapfg3gx2z9z6xj','application/javascript','',' // All functions that need access to the editor\'s state live inside\n// the CodeMirror function. Below that, at the bottom of the file,\n// some utilities are defined.\n\n// CodeMirror is the only global var we claim\nvar CodeMirror = (function() {\n  // This is the function that produces an editor instance. Its\n  // closure is used to store the editor state.\n  function CodeMirror(place, givenOptions) {\n    // Determine effective options based on given values and defaults.\n    var options = {}, defaults = CodeMirror.defaults;\n    for (var opt in defaults)\n      if (defaults.hasOwnProperty(opt))\n        options[opt] = (givenOptions && givenOptions.hasOwnProperty(opt) ? givenOptions : defaults)[opt];\n\n    // The element in which the editor lives.\n    var wrapper = document.createElement(\"div\");\n    wrapper.className = \"CodeMirror\" + (options.lineWrapping ? \" CodeMirror-wrap\" : \"\");\n    // This mess creates the base DOM structure for the editor.\n    wrapper.innerHTML =\n      \'<div style=\"overflow: hidden; position: relative; width: 3px; height: 0px;\">\' + // Wraps and hides input textarea\n        \'<textarea style=\"position: absolute; padding: 0; width: 1px; height: 1em\" wrap=\"off\" \' +\n          \'autocorrect=\"off\" autocapitalize=\"off\"></textarea></div>\' +\n      \'<div class=\"CodeMirror-scroll\" tabindex=\"-1\">\' +\n        \'<div style=\"position: relative\">\' + // Set to the height of the text, causes scrolling\n          \'<div style=\"position: relative\">\' + // Moved around its parent to cover visible view\n            \'<div class=\"CodeMirror-gutter\"><div class=\"CodeMirror-gutter-text\"></div></div>\' +\n            // Provides positioning relative to (visible) text origin\n            \'<div class=\"CodeMirror-lines\"><div style=\"position: relative; z-index: 0\">\' +\n              \'<div style=\"position: absolute; width: 100%; height: 0; overflow: hidden; visibility: hidden;\"></div>\' +\n              \'<pre class=\"CodeMirror-cursor\">&#160;</pre>\' + // Absolutely positioned blinky cursor\n              \'<div style=\"position: relative; z-index: -1\"></div><div></div>\' + // DIVs containing the selection and the actual code\n            \'</div></div></div></div></div>\';\n    if (place.appendChild) place.appendChild(wrapper); else place(wrapper);\n    // I\'ve never seen more elegant code in my life.\n    var inputDiv = wrapper.firstChild, input = inputDiv.firstChild,\n        scroller = wrapper.lastChild, code = scroller.firstChild,\n        mover = code.firstChild, gutter = mover.firstChild, gutterText = gutter.firstChild,\n        lineSpace = gutter.nextSibling.firstChild, measure = lineSpace.firstChild,\n        cursor = measure.nextSibling, selectionDiv = cursor.nextSibling,\n        lineDiv = selectionDiv.nextSibling;\n    themeChanged(); keyMapChanged();\n    // Needed to hide big blue blinking cursor on Mobile Safari\n    if (ios) input.style.width = \"0px\";\n    if (!webkit) lineSpace.draggable = true;\n    lineSpace.style.outline = \"none\";\n    if (options.tabindex != null) input.tabIndex = options.tabindex;\n    if (options.autofocus) focusInput();\n    if (!options.gutter && !options.lineNumbers) gutter.style.display = \"none\";\n    // Needed to handle Tab key in KHTML\n    if (khtml) inputDiv.style.height = \"1px\", inputDiv.style.position = \"absolute\";\n\n    // Check for problem with IE innerHTML not working when we have a\n    // P (or similar) parent node.\n    try { stringWidth(\"x\"); }\n    catch (e) {\n      if (e.message.match(/runtime/i))\n        e = new Error(\"A CodeMirror inside a P-style element does not work in Internet Explorer. (innerHTML bug)\");\n      throw e;\n    }\n\n    // Delayed object wrap timeouts, making sure only one is active. blinker holds an interval.\n    var poll = new Delayed(), highlight = new Delayed(), blinker;\n\n    // mode holds a mode API object. doc is the tree of Line objects,\n    // work an array of lines that should be parsed, and history the\n    // undo history (instance of History constructor).\n    var mode, doc = new BranchChunk([new LeafChunk([new Line(\"\")])]), work, focused;\n    loadMode();\n    // The selection. These are always maintained to point at valid\n    // positions. Inverted is used to remember that the user is\n    // selecting bottom-to-top.\n    var sel = {from: {line: 0, ch: 0}, to: {line: 0, ch: 0}, inverted: false};\n    // Selection-related flags. shiftSelecting obviously tracks\n    // whether the user is holding shift.\n    var shiftSelecting, lastClick, lastDoubleClick, lastScrollPos = 0, draggingText,\n        overwrite = false, suppressEdits = false;\n    // Variables used by startOperation/endOperation to track what\n    // happened during the operation.\n    var updateInput, userSelChange, changes, textChanged, selectionChanged, leaveInputAlone,\n        gutterDirty, callbacks, maxLengthChanged;\n    // Current visible range (may be bigger than the view window).\n    var displayOffset = 0, showingFrom = 0, showingTo = 0, lastSizeC = 0;\n    // bracketHighlighted is used to remember that a bracket has been\n    // marked.\n    var bracketHighlighted;\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    var maxLine = \"\", maxWidth;\n    var tabCache = {};\n\n    // Initialize the content.\n    operation(function(){setValue(options.value || \"\"); updateInput = false;})();\n    var history = new History();\n\n    // Register our event handlers.\n    connect(scroller, \"mousedown\", operation(onMouseDown));\n    connect(scroller, \"dblclick\", operation(onDoubleClick));\n    connect(lineSpace, \"selectstart\", e_preventDefault);\n    // Gecko browsers fire contextmenu *after* opening the menu, at\n    // which point we can\'t mess with it anymore. Context menu is\n    // handled in onMouseDown for Gecko.\n    if (!gecko) connect(scroller, \"contextmenu\", onContextMenu);\n    connect(scroller, \"scroll\", function() {\n      lastScrollPos = scroller.scrollTop;\n      updateDisplay([]);\n      if (options.fixedGutter) gutter.style.left = scroller.scrollLeft + \"px\";\n      if (options.onScroll) options.onScroll(instance);\n    });\n    connect(window, \"resize\", function() {updateDisplay(true);});\n    connect(input, \"keyup\", operation(onKeyUp));\n    connect(input, \"input\", fastPoll);\n    connect(input, \"keydown\", operation(onKeyDown));\n    connect(input, \"keypress\", operation(onKeyPress));\n    connect(input, \"focus\", onFocus);\n    connect(input, \"blur\", onBlur);\n\n    if (options.dragDrop) {\n      connect(lineSpace, \"dragstart\", onDragStart);\n      function drag_(e) {\n        if (options.onDragEvent && options.onDragEvent(instance, addStop(e))) return;\n        e_stop(e);\n      }\n      connect(scroller, \"dragenter\", drag_);\n      connect(scroller, \"dragover\", drag_);\n      connect(scroller, \"drop\", operation(onDrop));\n    }\n    connect(scroller, \"paste\", function(){focusInput(); fastPoll();});\n    connect(input, \"paste\", fastPoll);\n    connect(input, \"cut\", operation(function(){\n      if (!options.readOnly) replaceSelection(\"\");\n    }));\n\n    // Needed to handle Tab key in KHTML\n    if (khtml) connect(code, \"mouseup\", function() {\n        if (document.activeElement == input) input.blur();\n        focusInput();\n    });\n\n    // IE throws unspecified error in certain cases, when\n    // trying to access activeElement before onload\n    var hasFocus; try { hasFocus = (document.activeElement == input); } catch(e) { }\n    if (hasFocus || options.autofocus) setTimeout(onFocus, 20);\n    else onBlur();\n\n    function isLine(l) {return l >= 0 && l < doc.size;}\n    // The instance object that we\'ll return. Mostly calls out to\n    // local functions in the CodeMirror function. Some do some extra\n    // range checking and/or clipping. operation is used to wrap the\n    // call so that changes it makes are tracked, and the display is\n    // updated afterwards.\n    var instance = wrapper.CodeMirror = {\n      getValue: getValue,\n      setValue: operation(setValue),\n      getSelection: getSelection,\n      replaceSelection: operation(replaceSelection),\n      focus: function(){window.focus(); focusInput(); onFocus(); fastPoll();},\n      setOption: function(option, value) {\n        var oldVal = options[option];\n        options[option] = value;\n        if (option == \"mode\" || option == \"indentUnit\") loadMode();\n        else if (option == \"readOnly\" && value == \"nocursor\") {onBlur(); input.blur();}\n        else if (option == \"readOnly\" && !value) {resetInput(true);}\n        else if (option == \"theme\") themeChanged();\n        else if (option == \"lineWrapping\" && oldVal != value) operation(wrappingChanged)();\n        else if (option == \"tabSize\") updateDisplay(true);\n        else if (option == \"keyMap\") keyMapChanged();\n        if (option == \"lineNumbers\" || option == \"gutter\" || option == \"firstLineNumber\" || option == \"theme\") {\n          gutterChanged();\n          updateDisplay(true);\n        }\n      },\n      getOption: function(option) {return options[option];},\n      undo: operation(undo),\n      redo: operation(redo),\n      indentLine: operation(function(n, dir) {\n        if (typeof dir != \"string\") {\n          if (dir == null) dir = options.smartIndent ? \"smart\" : \"prev\";\n          else dir = dir ? \"add\" : \"subtract\";\n        }\n        if (isLine(n)) indentLine(n, dir);\n      }),\n      indentSelection: operation(indentSelected),\n      historySize: function() {return {undo: history.done.length, redo: history.undone.length};},\n      clearHistory: function() {history = new History();},\n      matchBrackets: operation(function(){matchBrackets(true);}),\n      getTokenAt: operation(function(pos) {\n        pos = clipPos(pos);\n        return getLine(pos.line).getTokenAt(mode, getStateBefore(pos.line), pos.ch);\n      }),\n      getStateAfter: function(line) {\n        line = clipLine(line == null ? doc.size - 1: line);\n        return getStateBefore(line + 1);\n      },\n      cursorCoords: function(start, mode) {\n        if (start == null) start = sel.inverted;\n        return this.charCoords(start ? sel.from : sel.to, mode);\n      },\n      charCoords: function(pos, mode) {\n        pos = clipPos(pos);\n        if (mode == \"local\") return localCoords(pos, false);\n        if (mode == \"div\") return localCoords(pos, true);\n        return pageCoords(pos);\n      },\n      coordsChar: function(coords) {\n        var off = eltOffset(lineSpace);\n        return coordsChar(coords.x - off.left, coords.y - off.top);\n      },\n      markText: operation(markText),\n      setBookmark: setBookmark,\n      findMarksAt: findMarksAt,\n      setMarker: operation(addGutterMarker),\n      clearMarker: operation(removeGutterMarker),\n      setLineClass: operation(setLineClass),\n      hideLine: operation(function(h) {return setLineHidden(h, true);}),\n      showLine: operation(function(h) {return setLineHidden(h, false);}),\n      onDeleteLine: function(line, f) {\n        if (typeof line == \"number\") {\n          if (!isLine(line)) return null;\n          line = getLine(line);\n        }\n        (line.handlers || (line.handlers = [])).push(f);\n        return line;\n      },\n      lineInfo: lineInfo,\n      addWidget: function(pos, node, scroll, vert, horiz) {\n        pos = localCoords(clipPos(pos));\n        var top = pos.yBot, left = pos.x;\n        node.style.position = \"absolute\";\n        code.appendChild(node);\n        if (vert == \"over\") top = pos.y;\n        else if (vert == \"near\") {\n          var vspace = Math.max(scroller.offsetHeight, doc.height * textHeight()),\n              hspace = Math.max(code.clientWidth, lineSpace.clientWidth) - paddingLeft();\n          if (pos.yBot + node.offsetHeight > vspace && pos.y > node.offsetHeight)\n            top = pos.y - node.offsetHeight;\n          if (left + node.offsetWidth > hspace)\n            left = hspace - node.offsetWidth;\n        }\n        node.style.top = (top + paddingTop()) + \"px\";\n        node.style.left = node.style.right = \"\";\n        if (horiz == \"right\") {\n          left = code.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") left = 0;\n          else if (horiz == \"middle\") left = (code.clientWidth - node.offsetWidth) / 2;\n          node.style.left = (left + paddingLeft()) + \"px\";\n        }\n        if (scroll)\n          scrollIntoView(left, top, left + node.offsetWidth, top + node.offsetHeight);\n      },\n\n      lineCount: function() {return doc.size;},\n      clipPos: clipPos,\n      getCursor: function(start) {\n        if (start == null) start = sel.inverted;\n        return copyPos(start ? sel.from : sel.to);\n      },\n      somethingSelected: function() {return !posEq(sel.from, sel.to);},\n      setCursor: operation(function(line, ch, user) {\n        if (ch == null && typeof line.line == \"number\") setCursor(line.line, line.ch, user);\n        else setCursor(line, ch, user);\n      }),\n      setSelection: operation(function(from, to, user) {\n        (user ? setSelectionUser : setSelection)(clipPos(from), clipPos(to || from));\n      }),\n      getLine: function(line) {if (isLine(line)) return getLine(line).text;},\n      getLineHandle: function(line) {if (isLine(line)) return getLine(line);},\n      setLine: operation(function(line, text) {\n        if (isLine(line)) replaceRange(text, {line: line, ch: 0}, {line: line, ch: getLine(line).text.length});\n      }),\n      removeLine: operation(function(line) {\n        if (isLine(line)) replaceRange(\"\", {line: line, ch: 0}, clipPos({line: line+1, ch: 0}));\n      }),\n      replaceRange: operation(replaceRange),\n      getRange: function(from, to) {return getRange(clipPos(from), clipPos(to));},\n\n      triggerOnKeyDown: operation(onKeyDown),\n      execCommand: function(cmd) {return commands[cmd](instance);},\n      // Stuff used by commands, probably not much use to outside code.\n      moveH: operation(moveH),\n      deleteH: operation(deleteH),\n      moveV: operation(moveV),\n      toggleOverwrite: function() {\n        if(overwrite){\n          overwrite = false;\n          cursor.className = cursor.className.replace(\" CodeMirror-overwrite\", \"\");\n        } else {\n          overwrite = true;\n          cursor.className += \" CodeMirror-overwrite\";\n        }\n      },\n\n      posFromIndex: function(off) {\n        var lineNo = 0, ch;\n        doc.iter(0, doc.size, function(line) {\n          var sz = line.text.length + 1;\n          if (sz > off) { ch = off; return true; }\n          off -= sz;\n          ++lineNo;\n        });\n        return clipPos({line: lineNo, ch: ch});\n      },\n      indexFromPos: function (coords) {\n        if (coords.line < 0 || coords.ch < 0) return 0;\n        var index = coords.ch;\n        doc.iter(0, coords.line, function (line) {\n          index += line.text.length + 1;\n        });\n        return index;\n      },\n      scrollTo: function(x, y) {\n        if (x != null) scroller.scrollLeft = x;\n        if (y != null) scroller.scrollTop = y;\n        updateDisplay([]);\n      },\n\n      operation: function(f){return operation(f)();},\n      compoundChange: function(f){return compoundChange(f);},\n      refresh: function(){\n        updateDisplay(true);\n        if (scroller.scrollHeight > lastScrollPos)\n          scroller.scrollTop = lastScrollPos;\n      },\n      getInputField: function(){return input;},\n      getWrapperElement: function(){return wrapper;},\n      getScrollerElement: function(){return scroller;},\n      getGutterElement: function(){return gutter;}\n    };\n\n    function getLine(n) { return getLineAt(doc, n); }\n    function updateLineHeight(line, height) {\n      gutterDirty = true;\n      var diff = height - line.height;\n      for (var n = line; n; n = n.parent) n.height += diff;\n    }\n\n    function setValue(code) {\n      var top = {line: 0, ch: 0};\n      updateLines(top, {line: doc.size - 1, ch: getLine(doc.size-1).text.length},\n                  splitLines(code), top, top);\n      updateInput = true;\n    }\n    function getValue() {\n      var text = [];\n      doc.iter(0, doc.size, function(line) { text.push(line.text); });\n      return text.join(\"\\n\");\n    }\n\n    function onMouseDown(e) {\n      setShift(e_prop(e, \"shiftKey\"));\n      // Check whether this is a click in a widget\n      for (var n = e_target(e); n != wrapper; n = n.parentNode)\n        if (n.parentNode == code && n != mover) return;\n\n      // See if this is a click in the gutter\n      for (var n = e_target(e); n != wrapper; n = n.parentNode)\n        if (n.parentNode == gutterText) {\n          if (options.onGutterClick)\n            options.onGutterClick(instance, indexOf(gutterText.childNodes, n) + showingFrom, e);\n          return e_preventDefault(e);\n        }\n\n      var start = posFromMouse(e);\n\n      switch (e_button(e)) {\n      case 3:\n        if (gecko && !mac) onContextMenu(e);\n        return;\n      case 2:\n        if (start) setCursor(start.line, start.ch, true);\n        setTimeout(focusInput, 20);\n        return;\n      }\n      // For button 1, if it was clicked inside the editor\n      // (posFromMouse returning non-null), we have to adjust the\n      // selection.\n      if (!start) {if (e_target(e) == scroller) e_preventDefault(e); return;}\n\n      if (!focused) onFocus();\n\n      var now = +new Date;\n      if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {\n        e_preventDefault(e);\n        setTimeout(focusInput, 20);\n        return selectLine(start.line);\n      } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {\n        lastDoubleClick = {time: now, pos: start};\n        e_preventDefault(e);\n        return selectWordAt(start);\n      } else { lastClick = {time: now, pos: start}; }\n\n      var last = start, going;\n      if (options.dragDrop && dragAndDrop && !options.readOnly && !posEq(sel.from, sel.to) &&\n          !posLess(start, sel.from) && !posLess(sel.to, start)) {\n        // Let the drag handler handle this.\n        if (webkit) lineSpace.draggable = true;\n        function dragEnd(e2) {\n          if (webkit) lineSpace.draggable = false;\n          draggingText = false;\n          up(); drop();\n          if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n            e_preventDefault(e2);\n            setCursor(start.line, start.ch, true);\n            focusInput();\n          }\n        }\n        var up = connect(document, \"mouseup\", operation(dragEnd), true);\n        var drop = connect(scroller, \"drop\", operation(dragEnd), true);\n        draggingText = true;\n        // IE\'s approach to draggable\n        if (lineSpace.dragDrop) lineSpace.dragDrop();\n        return;\n      }\n      e_preventDefault(e);\n      setCursor(start.line, start.ch, true);\n\n      function extend(e) {\n        var cur = posFromMouse(e, true);\n        if (cur && !posEq(cur, last)) {\n          if (!focused) onFocus();\n          last = cur;\n          setSelectionUser(start, cur);\n          updateInput = false;\n          var visible = visibleLines();\n          if (cur.line >= visible.to || cur.line < visible.from)\n            going = setTimeout(operation(function(){extend(e);}), 150);\n        }\n      }\n\n      function done(e) {\n        clearTimeout(going);\n        var cur = posFromMouse(e);\n        if (cur) setSelectionUser(start, cur);\n        e_preventDefault(e);\n        focusInput();\n        updateInput = true;\n        move(); up();\n      }\n      var move = connect(document, \"mousemove\", operation(function(e) {\n        clearTimeout(going);\n        e_preventDefault(e);\n        if (!ie && !e_button(e)) done(e);\n        else extend(e);\n      }), true);\n      var up = connect(document, \"mouseup\", operation(done), true);\n    }\n    function onDoubleClick(e) {\n      for (var n = e_target(e); n != wrapper; n = n.parentNode)\n        if (n.parentNode == gutterText) return e_preventDefault(e);\n      var start = posFromMouse(e);\n      if (!start) return;\n      lastDoubleClick = {time: +new Date, pos: start};\n      e_preventDefault(e);\n      selectWordAt(start);\n    }\n    function onDrop(e) {\n      if (options.onDragEvent && options.onDragEvent(instance, addStop(e))) return;\n      e.preventDefault();\n      var pos = posFromMouse(e, true), files = e.dataTransfer.files;\n      if (!pos || options.readOnly) return;\n      if (files && files.length && window.FileReader && window.File) {\n        function loadFile(file, i) {\n          var reader = new FileReader;\n          reader.onload = function() {\n            text[i] = reader.result;\n            if (++read == n) {\n              pos = clipPos(pos);\n              operation(function() {\n                var end = replaceRange(text.join(\"\"), pos, pos);\n                setSelectionUser(pos, end);\n              })();\n            }\n          };\n          reader.readAsText(file);\n        }\n        var n = files.length, text = Array(n), read = 0;\n        for (var i = 0; i < n; ++i) loadFile(files[i], i);\n      }\n      else {\n        try {\n          var text = e.dataTransfer.getData(\"Text\");\n          if (text) {\n            compoundChange(function() {\n              var curFrom = sel.from, curTo = sel.to;\n              setSelectionUser(pos, pos);\n              if (draggingText) replaceRange(\"\", curFrom, curTo);\n              replaceSelection(text);\n              focusInput();\n            });\n          }\n        }\n        catch(e){}\n      }\n    }\n    function onDragStart(e) {\n      var txt = getSelection();\n      e.dataTransfer.setData(\"Text\", txt);\n      \n      // Use dummy image instead of default browsers image.\n      if (gecko || chrome) {\n        var img = document.createElement(\'img\');\n        img.scr = \'data:image/gif;base64,R0lGODdhAgACAIAAAAAAAP///ywAAAAAAgACAAACAoRRADs=\'; //1x1 image\n        e.dataTransfer.setDragImage(img, 0, 0);\n      }\n    }\n\n    function doHandleBinding(bound, dropShift) {\n      if (typeof bound == \"string\") {\n        bound = commands[bound];\n        if (!bound) return false;\n      }\n      var prevShift = shiftSelecting;\n      try {\n        if (options.readOnly) suppressEdits = true;\n        if (dropShift) shiftSelecting = null;\n        bound(instance);\n      } catch(e) {\n        if (e != Pass) throw e;\n        return false;\n      } finally {\n        shiftSelecting = prevShift;\n        suppressEdits = false;\n      }\n      return true;\n    }\n    function handleKeyBinding(e) {\n      // Handle auto keymap transitions\n      var startMap = getKeyMap(options.keyMap), next = startMap.auto;\n      clearTimeout(maybeTransition);\n      if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {\n        if (getKeyMap(options.keyMap) == startMap) {\n          options.keyMap = (next.call ? next.call(null, instance) : next);\n        }\n      }, 50);\n\n      var name = keyNames[e_prop(e, \"keyCode\")], handled = false;\n      if (name == null || e.altGraphKey) return false;\n      if (e_prop(e, \"altKey\")) name = \"Alt-\" + name;\n      if (e_prop(e, \"ctrlKey\")) name = \"Ctrl-\" + name;\n      if (e_prop(e, \"metaKey\")) name = \"Cmd-\" + name;\n\n      var stopped = false;\n      function stop() { stopped = true; }\n\n      if (e_prop(e, \"shiftKey\")) {\n        handled = lookupKey(\"Shift-\" + name, options.extraKeys, options.keyMap,\n                            function(b) {return doHandleBinding(b, true);}, stop)\n               || lookupKey(name, options.extraKeys, options.keyMap, function(b) {\n                 if (typeof b == \"string\" && /^go[A-Z]/.test(b)) return doHandleBinding(b);\n               }, stop);\n      } else {\n        handled = lookupKey(name, options.extraKeys, options.keyMap, doHandleBinding, stop);\n      }\n      if (stopped) handled = false;\n      if (handled) {\n        e_preventDefault(e);\n        restartBlink();\n        if (ie) { e.oldKeyCode = e.keyCode; e.keyCode = 0; }\n      }\n      return handled;\n    }\n    function handleCharBinding(e, ch) {\n      var handled = lookupKey(\"\'\" + ch + \"\'\", options.extraKeys,\n                              options.keyMap, function(b) { return doHandleBinding(b, true); });\n      if (handled) {\n        e_preventDefault(e);\n        restartBlink();\n      }\n      return handled;\n    }\n\n    var lastStoppedKey = null, maybeTransition;\n    function onKeyDown(e) {\n      if (!focused) onFocus();\n      if (ie && e.keyCode == 27) { e.returnValue = false; }\n      if (pollingFast) { if (readInput()) pollingFast = false; }\n      if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;\n      var code = e_prop(e, \"keyCode\");\n      // IE does strange things with escape.\n      setShift(code == 16 || e_prop(e, \"shiftKey\"));\n      // First give onKeyEvent option a chance to handle this.\n      var handled = handleKeyBinding(e);\n      if (window.opera) {\n        lastStoppedKey = handled ? code : null;\n        // Opera has no cut event... we try to at least catch the key combo\n        if (!handled && code == 88 && e_prop(e, mac ? \"metaKey\" : \"ctrlKey\"))\n          replaceSelection(\"\");\n      }\n    }\n    function onKeyPress(e) {\n      if (pollingFast) readInput();\n      if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;\n      var keyCode = e_prop(e, \"keyCode\"), charCode = e_prop(e, \"charCode\");\n      if (window.opera && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n      if (((window.opera && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(e)) return;\n      var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n      if (options.electricChars && mode.electricChars && options.smartIndent && !options.readOnly) {\n        if (mode.electricChars.indexOf(ch) > -1)\n          setTimeout(operation(function() {indentLine(sel.to.line, \"smart\");}), 75);\n      }\n      if (handleCharBinding(e, ch)) return;\n      fastPoll();\n    }\n    function onKeyUp(e) {\n      if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;\n      if (e_prop(e, \"keyCode\") == 16) shiftSelecting = null;\n    }\n\n    function onFocus() {\n      if (options.readOnly == \"nocursor\") return;\n      if (!focused) {\n        if (options.onFocus) options.onFocus(instance);\n        focused = true;\n        if (wrapper.className.search(/\\bCodeMirror-focused\\b/) == -1)\n          wrapper.className += \" CodeMirror-focused\";\n        if (!leaveInputAlone) resetInput(true);\n      }\n      slowPoll();\n      restartBlink();\n    }\n    function onBlur() {\n      if (focused) {\n        if (options.onBlur) options.onBlur(instance);\n        focused = false;\n        if (bracketHighlighted)\n          operation(function(){\n            if (bracketHighlighted) { bracketHighlighted(); bracketHighlighted = null; }\n          })();\n        wrapper.className = wrapper.className.replace(\" CodeMirror-focused\", \"\");\n      }\n      clearInterval(blinker);\n      setTimeout(function() {if (!focused) shiftSelecting = null;}, 150);\n    }\n\n    // Replace the range from from to to by the strings in newText.\n    // Afterwards, set the selection to selFrom, selTo.\n    function updateLines(from, to, newText, selFrom, selTo) {\n      if (suppressEdits) return;\n      if (history) {\n        var old = [];\n        doc.iter(from.line, to.line + 1, function(line) { old.push(line.text); });\n        history.addChange(from.line, newText.length, old);\n        while (history.done.length > options.undoDepth) history.done.shift();\n      }\n      updateLinesNoUndo(from, to, newText, selFrom, selTo);\n    }\n    function unredoHelper(from, to) {\n      if (!from.length) return;\n      var set = from.pop(), out = [];\n      for (var i = set.length - 1; i >= 0; i -= 1) {\n        var change = set[i];\n        var replaced = [], end = change.start + change.added;\n        doc.iter(change.start, end, function(line) { replaced.push(line.text); });\n        out.push({start: change.start, added: change.old.length, old: replaced});\n        var pos = clipPos({line: change.start + change.old.length - 1,\n                           ch: editEnd(replaced[replaced.length-1], change.old[change.old.length-1])});\n        updateLinesNoUndo({line: change.start, ch: 0}, {line: end - 1, ch: getLine(end-1).text.length}, change.old, pos, pos);\n      }\n      updateInput = true;\n      to.push(out);\n    }\n    function undo() {unredoHelper(history.done, history.undone);}\n    function redo() {unredoHelper(history.undone, history.done);}\n\n    function updateLinesNoUndo(from, to, newText, selFrom, selTo) {\n      if (suppressEdits) return;\n      var recomputeMaxLength = false, maxLineLength = maxLine.length;\n      if (!options.lineWrapping)\n        doc.iter(from.line, to.line + 1, function(line) {\n          if (!line.hidden && line.text.length == maxLineLength) {recomputeMaxLength = true; return true;}\n        });\n      if (from.line != to.line || newText.length > 1) gutterDirty = true;\n\n      var nlines = to.line - from.line, firstLine = getLine(from.line), lastLine = getLine(to.line);\n      // First adjust the line structure, taking some care to leave highlighting intact.\n      if (from.ch == 0 && to.ch == 0 && newText[newText.length - 1] == \"\") {\n        // This is a whole-line replace. Treated specially to make\n        // sure line objects move the way they are supposed to.\n        var added = [], prevLine = null;\n        if (from.line) {\n          prevLine = getLine(from.line - 1);\n          prevLine.fixMarkEnds(lastLine);\n        } else lastLine.fixMarkStarts();\n        for (var i = 0, e = newText.length - 1; i < e; ++i)\n          added.push(Line.inheritMarks(newText[i], prevLine));\n        if (nlines) doc.remove(from.line, nlines, callbacks);\n        if (added.length) doc.insert(from.line, added);\n      } else if (firstLine == lastLine) {\n        if (newText.length == 1)\n          firstLine.replace(from.ch, to.ch, newText[0]);\n        else {\n          lastLine = firstLine.split(to.ch, newText[newText.length-1]);\n          firstLine.replace(from.ch, null, newText[0]);\n          firstLine.fixMarkEnds(lastLine);\n          var added = [];\n          for (var i = 1, e = newText.length - 1; i < e; ++i)\n            added.push(Line.inheritMarks(newText[i], firstLine));\n          added.push(lastLine);\n          doc.insert(from.line + 1, added);\n        }\n      } else if (newText.length == 1) {\n        firstLine.replace(from.ch, null, newText[0]);\n        lastLine.replace(null, to.ch, \"\");\n        firstLine.append(lastLine);\n        doc.remove(from.line + 1, nlines, callbacks);\n      } else {\n        var added = [];\n        firstLine.replace(from.ch, null, newText[0]);\n        lastLine.replace(null, to.ch, newText[newText.length-1]);\n        firstLine.fixMarkEnds(lastLine);\n        for (var i = 1, e = newText.length - 1; i < e; ++i)\n          added.push(Line.inheritMarks(newText[i], firstLine));\n        if (nlines > 1) doc.remove(from.line + 1, nlines - 1, callbacks);\n        doc.insert(from.line + 1, added);\n      }\n      if (options.lineWrapping) {\n        var perLine = Math.max(5, scroller.clientWidth / charWidth() - 3);\n        doc.iter(from.line, from.line + newText.length, function(line) {\n          if (line.hidden) return;\n          var guess = Math.ceil(line.text.length / perLine) || 1;\n          if (guess != line.height) updateLineHeight(line, guess);\n        });\n      } else {\n        doc.iter(from.line, from.line + newText.length, function(line) {\n          var l = line.text;\n          if (!line.hidden && l.length > maxLineLength) {\n            maxLine = l; maxLineLength = l.length; maxWidth = null;\n            recomputeMaxLength = false;\n          }\n        });\n        if (recomputeMaxLength) maxLengthChanged = true;\n      }\n\n      // Add these lines to the work array, so that they will be\n      // highlighted. Adjust work lines if lines were added/removed.\n      var newWork = [], lendiff = newText.length - nlines - 1;\n      for (var i = 0, l = work.length; i < l; ++i) {\n        var task = work[i];\n        if (task < from.line) newWork.push(task);\n        else if (task > to.line) newWork.push(task + lendiff);\n      }\n      var hlEnd = from.line + Math.min(newText.length, 500);\n      highlightLines(from.line, hlEnd);\n      newWork.push(hlEnd);\n      work = newWork;\n      startWorker(100);\n      // Remember that these lines changed, for updating the display\n      changes.push({from: from.line, to: to.line + 1, diff: lendiff});\n      var changeObj = {from: from, to: to, text: newText};\n      if (textChanged) {\n        for (var cur = textChanged; cur.next; cur = cur.next) {}\n        cur.next = changeObj;\n      } else textChanged = changeObj;\n\n      // Update the selection\n      function updateLine(n) {return n <= Math.min(to.line, to.line + lendiff) ? n : n + lendiff;}\n      setSelection(selFrom, selTo, updateLine(sel.from.line), updateLine(sel.to.line));\n\n      // Make sure the scroll-size div has the correct height.\n      if (scroller.clientHeight)\n        code.style.height = (doc.height * textHeight() + 2 * paddingTop()) + \"px\";\n    }\n    \n    function computeMaxLength() {\n      var maxLineLength = 0; \n      maxLine = \"\"; maxWidth = null;\n      doc.iter(0, doc.size, function(line) {\n        var l = line.text;\n        if (!line.hidden && l.length > maxLineLength) {\n          maxLineLength = l.length; maxLine = l;\n        }\n      });\n      maxLengthChanged = false;\n    }\n\n    function replaceRange(code, from, to) {\n      from = clipPos(from);\n      if (!to) to = from; else to = clipPos(to);\n      code = splitLines(code);\n      function adjustPos(pos) {\n        if (posLess(pos, from)) return pos;\n        if (!posLess(to, pos)) return end;\n        var line = pos.line + code.length - (to.line - from.line) - 1;\n        var ch = pos.ch;\n        if (pos.line == to.line)\n          ch += code[code.length-1].length - (to.ch - (to.line == from.line ? from.ch : 0));\n        return {line: line, ch: ch};\n      }\n      var end;\n      replaceRange1(code, from, to, function(end1) {\n        end = end1;\n        return {from: adjustPos(sel.from), to: adjustPos(sel.to)};\n      });\n      return end;\n    }\n    function replaceSelection(code, collapse) {\n      replaceRange1(splitLines(code), sel.from, sel.to, function(end) {\n        if (collapse == \"end\") return {from: end, to: end};\n        else if (collapse == \"start\") return {from: sel.from, to: sel.from};\n        else return {from: sel.from, to: end};\n      });\n    }\n    function replaceRange1(code, from, to, computeSel) {\n      var endch = code.length == 1 ? code[0].length + from.ch : code[code.length-1].length;\n      var newSel = computeSel({line: from.line + code.length - 1, ch: endch});\n      updateLines(from, to, code, newSel.from, newSel.to);\n    }\n\n    function getRange(from, to) {\n      var l1 = from.line, l2 = to.line;\n      if (l1 == l2) return getLine(l1).text.slice(from.ch, to.ch);\n      var code = [getLine(l1).text.slice(from.ch)];\n      doc.iter(l1 + 1, l2, function(line) { code.push(line.text); });\n      code.push(getLine(l2).text.slice(0, to.ch));\n      return code.join(\"\\n\");\n    }\n    function getSelection() {\n      return getRange(sel.from, sel.to);\n    }\n\n    var pollingFast = false; // Ensures slowPoll doesn\'t cancel fastPoll\n    function slowPoll() {\n      if (pollingFast) return;\n      poll.set(options.pollInterval, function() {\n        startOperation();\n        readInput();\n        if (focused) slowPoll();\n        endOperation();\n      });\n    }\n    function fastPoll() {\n      var missed = false;\n      pollingFast = true;\n      function p() {\n        startOperation();\n        var changed = readInput();\n        if (!changed && !missed) {missed = true; poll.set(60, p);}\n        else {pollingFast = false; slowPoll();}\n        endOperation();\n      }\n      poll.set(20, p);\n    }\n\n    // Previnput is a hack to work with IME. If we reset the textarea\n    // on every change, that breaks IME. So we look for changes\n    // compared to the previous content instead. (Modern browsers have\n    // events that indicate IME taking place, but these are not widely\n    // supported or compatible enough yet to rely on.)\n    var prevInput = \"\";\n    function readInput() {\n      if (leaveInputAlone || !focused || hasSelection(input) || options.readOnly) return false;\n      var text = input.value;\n      if (text == prevInput) return false;\n      shiftSelecting = null;\n      var same = 0, l = Math.min(prevInput.length, text.length);\n      while (same < l && prevInput[same] == text[same]) ++same;\n      if (same < prevInput.length)\n        sel.from = {line: sel.from.line, ch: sel.from.ch - (prevInput.length - same)};\n      else if (overwrite && posEq(sel.from, sel.to))\n        sel.to = {line: sel.to.line, ch: Math.min(getLine(sel.to.line).text.length, sel.to.ch + (text.length - same))};\n      replaceSelection(text.slice(same), \"end\");\n      if (text.length > 1000) { input.value = prevInput = \"\"; }\n      else prevInput = text;\n      return true;\n    }\n    function resetInput(user) {\n      if (!posEq(sel.from, sel.to)) {\n        prevInput = \"\";\n        input.value = getSelection();\n        selectInput(input);\n      } else if (user) prevInput = input.value = \"\";\n    }\n\n    function focusInput() {\n      if (options.readOnly != \"nocursor\") input.focus();\n    }\n\n    function scrollEditorIntoView() {\n      if (!cursor.getBoundingClientRect) return;\n      var rect = cursor.getBoundingClientRect();\n      // IE returns bogus coordinates when the instance sits inside of an iframe and the cursor is hidden\n      if (ie && rect.top == rect.bottom) return;\n      var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);\n      if (rect.top < 0 || rect.bottom > winH) cursor.scrollIntoView();\n    }\n    function scrollCursorIntoView() {\n      var cursor = localCoords(sel.inverted ? sel.from : sel.to);\n      var x = options.lineWrapping ? Math.min(cursor.x, lineSpace.offsetWidth) : cursor.x;\n      return scrollIntoView(x, cursor.y, x, cursor.yBot);\n    }\n    function scrollIntoView(x1, y1, x2, y2) {\n      var pl = paddingLeft(), pt = paddingTop();\n      y1 += pt; y2 += pt; x1 += pl; x2 += pl;\n      var screen = scroller.clientHeight, screentop = scroller.scrollTop, scrolled = false, result = true;\n      if (y1 < screentop) {scroller.scrollTop = Math.max(0, y1); scrolled = true;}\n      else if (y2 > screentop + screen) {scroller.scrollTop = y2 - screen; scrolled = true;}\n\n      var screenw = scroller.clientWidth, screenleft = scroller.scrollLeft;\n      var gutterw = options.fixedGutter ? gutter.clientWidth : 0;\n      var atLeft = x1 < gutterw + pl + 10;\n      if (x1 < screenleft + gutterw || atLeft) {\n        if (atLeft) x1 = 0;\n        scroller.scrollLeft = Math.max(0, x1 - 10 - gutterw);\n        scrolled = true;\n      }\n      else if (x2 > screenw + screenleft - 3) {\n        scroller.scrollLeft = x2 + 10 - screenw;\n        scrolled = true;\n        if (x2 > code.clientWidth) result = false;\n      }\n      if (scrolled && options.onScroll) options.onScroll(instance);\n      return result;\n    }\n\n    function visibleLines() {\n      var lh = textHeight(), top = scroller.scrollTop - paddingTop();\n      var fromHeight = Math.max(0, Math.floor(top / lh));\n      var toHeight = Math.ceil((top + scroller.clientHeight) / lh);\n      return {from: lineAtHeight(doc, fromHeight),\n              to: lineAtHeight(doc, toHeight)};\n    }\n    // Uses a set of changes plus the current scroll position to\n    // determine which DOM updates have to be made, and makes the\n    // updates.\n    function updateDisplay(changes, suppressCallback) {\n      if (!scroller.clientWidth) {\n        showingFrom = showingTo = displayOffset = 0;\n        return;\n      }\n      // Compute the new visible window\n      var visible = visibleLines();\n      // Bail out if the visible area is already rendered and nothing changed.\n      if (changes !== true && changes.length == 0 && visible.from > showingFrom && visible.to < showingTo) return;\n      var from = Math.max(visible.from - 100, 0), to = Math.min(doc.size, visible.to + 100);\n      if (showingFrom < from && from - showingFrom < 20) from = showingFrom;\n      if (showingTo > to && showingTo - to < 20) to = Math.min(doc.size, showingTo);\n\n      // Create a range of theoretically intact lines, and punch holes\n      // in that using the change info.\n      var intact = changes === true ? [] :\n        computeIntact([{from: showingFrom, to: showingTo, domStart: 0}], changes);\n      // Clip off the parts that won\'t be visible\n      var intactLines = 0;\n      for (var i = 0; i < intact.length; ++i) {\n        var range = intact[i];\n        if (range.from < from) {range.domStart += (from - range.from); range.from = from;}\n        if (range.to > to) range.to = to;\n        if (range.from >= range.to) intact.splice(i--, 1);\n        else intactLines += range.to - range.from;\n      }\n      if (intactLines == to - from && from == showingFrom && to == showingTo) return;\n      intact.sort(function(a, b) {return a.domStart - b.domStart;});\n\n      var th = textHeight(), gutterDisplay = gutter.style.display;\n      lineDiv.style.display = \"none\";\n      patchDisplay(from, to, intact);\n      lineDiv.style.display = gutter.style.display = \"\";\n\n      // Position the mover div to align with the lines it\'s supposed\n      // to be showing (which will cover the visible display)\n      var different = from != showingFrom || to != showingTo || lastSizeC != scroller.clientHeight + th;\n      // This is just a bogus formula that detects when the editor is\n      // resized or the font size changes.\n      if (different) lastSizeC = scroller.clientHeight + th;\n      showingFrom = from; showingTo = to;\n      displayOffset = heightAtLine(doc, from);\n      mover.style.top = (displayOffset * th) + \"px\";\n      if (scroller.clientHeight)\n        code.style.height = (doc.height * th + 2 * paddingTop()) + \"px\";\n\n      // Since this is all rather error prone, it is honoured with the\n      // only assertion in the whole file.\n      if (lineDiv.childNodes.length != showingTo - showingFrom)\n        throw new Error(\"BAD PATCH! \" + JSON.stringify(intact) + \" size=\" + (showingTo - showingFrom) +\n                        \" nodes=\" + lineDiv.childNodes.length);\n\n      function checkHeights() {\n        maxWidth = scroller.clientWidth;\n        var curNode = lineDiv.firstChild, heightChanged = false;\n        doc.iter(showingFrom, showingTo, function(line) {\n          if (!line.hidden) {\n            var height = Math.round(curNode.offsetHeight / th) || 1;\n            if (line.height != height) {\n              updateLineHeight(line, height);\n              gutterDirty = heightChanged = true;\n            }\n          }\n          curNode = curNode.nextSibling;\n        });\n        if (heightChanged)\n          code.style.height = (doc.height * th + 2 * paddingTop()) + \"px\";\n        return heightChanged;\n      }\n\n      if (options.lineWrapping) {\n        checkHeights();\n      } else {\n        if (maxWidth == null) maxWidth = stringWidth(maxLine);\n        if (maxWidth > scroller.clientWidth) {\n          lineSpace.style.width = maxWidth + \"px\";\n          // Needed to prevent odd wrapping/hiding of widgets placed in here.\n          code.style.width = \"\";\n          code.style.width = scroller.scrollWidth + \"px\";\n        } else {\n          lineSpace.style.width = code.style.width = \"\";\n        }\n      }\n\n      gutter.style.display = gutterDisplay;\n      if (different || gutterDirty) {\n        // If the gutter grew in size, re-check heights. If those changed, re-draw gutter.\n        updateGutter() && options.lineWrapping && checkHeights() && updateGutter();\n      }\n      updateSelection();\n      if (!suppressCallback && options.onUpdate) options.onUpdate(instance);\n      return true;\n    }\n\n    function computeIntact(intact, changes) {\n      for (var i = 0, l = changes.length || 0; i < l; ++i) {\n        var change = changes[i], intact2 = [], diff = change.diff || 0;\n        for (var j = 0, l2 = intact.length; j < l2; ++j) {\n          var range = intact[j];\n          if (change.to <= range.from && change.diff)\n            intact2.push({from: range.from + diff, to: range.to + diff,\n                          domStart: range.domStart});\n          else if (change.to <= range.from || change.from >= range.to)\n            intact2.push(range);\n          else {\n            if (change.from > range.from)\n              intact2.push({from: range.from, to: change.from, domStart: range.domStart});\n            if (change.to < range.to)\n              intact2.push({from: change.to + diff, to: range.to + diff,\n                            domStart: range.domStart + (change.to - range.from)});\n          }\n        }\n        intact = intact2;\n      }\n      return intact;\n    }\n\n    function patchDisplay(from, to, intact) {\n      // The first pass removes the DOM nodes that aren\'t intact.\n      if (!intact.length) lineDiv.innerHTML = \"\";\n      else {\n        function killNode(node) {\n          var tmp = node.nextSibling;\n          node.parentNode.removeChild(node);\n          return tmp;\n        }\n        var domPos = 0, curNode = lineDiv.firstChild, n;\n        for (var i = 0; i < intact.length; ++i) {\n          var cur = intact[i];\n          while (cur.domStart > domPos) {curNode = killNode(curNode); domPos++;}\n          for (var j = 0, e = cur.to - cur.from; j < e; ++j) {curNode = curNode.nextSibling; domPos++;}\n        }\n        while (curNode) curNode = killNode(curNode);\n      }\n      // This pass fills in the lines that actually changed.\n      var nextIntact = intact.shift(), curNode = lineDiv.firstChild, j = from;\n      var scratch = document.createElement(\"div\");\n      doc.iter(from, to, function(line) {\n        if (nextIntact && nextIntact.to == j) nextIntact = intact.shift();\n        if (!nextIntact || nextIntact.from > j) {\n          if (line.hidden) var html = scratch.innerHTML = \"<pre></pre>\";\n          else {\n            var html = \'<pre\' + (line.className ? \' class=\"\' + line.className + \'\"\' : \'\') + \'>\'\n              + line.getHTML(makeTab) + \'</pre>\';\n            // Kludge to make sure the styled element lies behind the selection (by z-index)\n            if (line.bgClassName)\n              html = \'<div style=\"position: relative\"><pre class=\"\' + line.bgClassName +\n              \'\" style=\"position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: -2\">&#160;</pre>\' + html + \"</div>\";\n          }\n          scratch.innerHTML = html;\n          lineDiv.insertBefore(scratch.firstChild, curNode);\n        } else {\n          curNode = curNode.nextSibling;\n        }\n        ++j;\n      });\n    }\n\n    function updateGutter() {\n      if (!options.gutter && !options.lineNumbers) return;\n      var hText = mover.offsetHeight, hEditor = scroller.clientHeight;\n      gutter.style.height = (hText - hEditor < 2 ? hEditor : hText) + \"px\";\n      var html = [], i = showingFrom, normalNode;\n      doc.iter(showingFrom, Math.max(showingTo, showingFrom + 1), function(line) {\n        if (line.hidden) {\n          html.push(\"<pre></pre>\");\n        } else {\n          var marker = line.gutterMarker;\n          var text = options.lineNumbers ? i + options.firstLineNumber : null;\n          if (marker && marker.text)\n            text = marker.text.replace(\"%N%\", text != null ? text : \"\");\n          else if (text == null)\n            text = \"\\u00a0\";\n          html.push((marker && marker.style ? \'<pre class=\"\' + marker.style + \'\">\' : \"<pre>\"), text);\n          for (var j = 1; j < line.height; ++j) html.push(\"<br/>&#160;\");\n          html.push(\"</pre>\");\n          if (!marker) normalNode = i;\n        }\n        ++i;\n      });\n      gutter.style.display = \"none\";\n      gutterText.innerHTML = html.join(\"\");\n      // Make sure scrolling doesn\'t cause number gutter size to pop\n      if (normalNode != null) {\n        var node = gutterText.childNodes[normalNode - showingFrom];\n        var minwidth = String(doc.size).length, val = eltText(node), pad = \"\";\n        while (val.length + pad.length < minwidth) pad += \"\\u00a0\";\n        if (pad) node.insertBefore(document.createTextNode(pad), node.firstChild);\n      }\n      gutter.style.display = \"\";\n      var resized = Math.abs((parseInt(lineSpace.style.marginLeft) || 0) - gutter.offsetWidth) > 2;\n      lineSpace.style.marginLeft = gutter.offsetWidth + \"px\";\n      gutterDirty = false;\n      return resized;\n    }\n    function updateSelection() {\n      var collapsed = posEq(sel.from, sel.to);\n      var fromPos = localCoords(sel.from, true);\n      var toPos = collapsed ? fromPos : localCoords(sel.to, true);\n      var headPos = sel.inverted ? fromPos : toPos, th = textHeight();\n      var wrapOff = eltOffset(wrapper), lineOff = eltOffset(lineDiv);\n      inputDiv.style.top = Math.max(0, Math.min(scroller.offsetHeight, headPos.y + lineOff.top - wrapOff.top)) + \"px\";\n      inputDiv.style.left = Math.max(0, Math.min(scroller.offsetWidth, headPos.x + lineOff.left - wrapOff.left)) + \"px\";\n      if (collapsed) {\n        cursor.style.top = headPos.y + \"px\";\n        cursor.style.left = (options.lineWrapping ? Math.min(headPos.x, lineSpace.offsetWidth) : headPos.x) + \"px\";\n        cursor.style.display = \"\";\n        selectionDiv.style.display = \"none\";\n      } else {\n        var sameLine = fromPos.y == toPos.y, html = \"\";\n        var clientWidth = lineSpace.clientWidth || lineSpace.offsetWidth;\n        var clientHeight = lineSpace.clientHeight || lineSpace.offsetHeight;\n        function add(left, top, right, height) {\n          var rstyle = quirksMode ? \"width: \" + (!right ? clientWidth : clientWidth - right - left) + \"px\"\n                                  : \"right: \" + right + \"px\";\n          html += \'<div class=\"CodeMirror-selected\" style=\"position: absolute; left: \' + left +\n            \'px; top: \' + top + \'px; \' + rstyle + \'; height: \' + height + \'px\"></div>\';\n        }\n        if (sel.from.ch && fromPos.y >= 0) {\n          var right = sameLine ? clientWidth - toPos.x : 0;\n          add(fromPos.x, fromPos.y, right, th);\n        }\n        var middleStart = Math.max(0, fromPos.y + (sel.from.ch ? th : 0));\n        var middleHeight = Math.min(toPos.y, clientHeight) - middleStart;\n        if (middleHeight > 0.2 * th)\n          add(0, middleStart, 0, middleHeight);\n        if ((!sameLine || !sel.from.ch) && toPos.y < clientHeight - .5 * th)\n          add(0, toPos.y, clientWidth - toPos.x, th);\n        selectionDiv.innerHTML = html;\n        cursor.style.display = \"none\";\n        selectionDiv.style.display = \"\";\n      }\n    }\n\n    function setShift(val) {\n      if (val) shiftSelecting = shiftSelecting || (sel.inverted ? sel.to : sel.from);\n      else shiftSelecting = null;\n    }\n    function setSelectionUser(from, to) {\n      var sh = shiftSelecting && clipPos(shiftSelecting);\n      if (sh) {\n        if (posLess(sh, from)) from = sh;\n        else if (posLess(to, sh)) to = sh;\n      }\n      setSelection(from, to);\n      userSelChange = true;\n    }\n    // Update the selection. Last two args are only used by\n    // updateLines, since they have to be expressed in the line\n    // numbers before the update.\n    function setSelection(from, to, oldFrom, oldTo) {\n      goalColumn = null;\n      if (oldFrom == null) {oldFrom = sel.from.line; oldTo = sel.to.line;}\n      if (posEq(sel.from, from) && posEq(sel.to, to)) return;\n      if (posLess(to, from)) {var tmp = to; to = from; from = tmp;}\n\n      // Skip over hidden lines.\n      if (from.line != oldFrom) {\n        var from1 = skipHidden(from, oldFrom, sel.from.ch);\n        // If there is no non-hidden line left, force visibility on current line\n        if (!from1) setLineHidden(from.line, false);\n        else from = from1;\n      }\n      if (to.line != oldTo) to = skipHidden(to, oldTo, sel.to.ch);\n\n      if (posEq(from, to)) sel.inverted = false;\n      else if (posEq(from, sel.to)) sel.inverted = false;\n      else if (posEq(to, sel.from)) sel.inverted = true;\n\n      if (options.autoClearEmptyLines && posEq(sel.from, sel.to)) {\n        var head = sel.inverted ? from : to;\n        if (head.line != sel.from.line && sel.from.line < doc.size) {\n          var oldLine = getLine(sel.from.line);\n          if (/^\\s+$/.test(oldLine.text))\n            setTimeout(operation(function() {\n              if (oldLine.parent && /^\\s+$/.test(oldLine.text)) {\n                var no = lineNo(oldLine);\n                replaceRange(\"\", {line: no, ch: 0}, {line: no, ch: oldLine.text.length});\n              }\n            }, 10));\n        }\n      }\n\n      sel.from = from; sel.to = to;\n      selectionChanged = true;\n    }\n    function skipHidden(pos, oldLine, oldCh) {\n      function getNonHidden(dir) {\n        var lNo = pos.line + dir, end = dir == 1 ? doc.size : -1;\n        while (lNo != end) {\n          var line = getLine(lNo);\n          if (!line.hidden) {\n            var ch = pos.ch;\n            if (toEnd || ch > oldCh || ch > line.text.length) ch = line.text.length;\n            return {line: lNo, ch: ch};\n          }\n          lNo += dir;\n        }\n      }\n      var line = getLine(pos.line);\n      var toEnd = pos.ch == line.text.length && pos.ch != oldCh;\n      if (!line.hidden) return pos;\n      if (pos.line >= oldLine) return getNonHidden(1) || getNonHidden(-1);\n      else return getNonHidden(-1) || getNonHidden(1);\n    }\n    function setCursor(line, ch, user) {\n      var pos = clipPos({line: line, ch: ch || 0});\n      (user ? setSelectionUser : setSelection)(pos, pos);\n    }\n\n    function clipLine(n) {return Math.max(0, Math.min(n, doc.size-1));}\n    function clipPos(pos) {\n      if (pos.line < 0) return {line: 0, ch: 0};\n      if (pos.line >= doc.size) return {line: doc.size-1, ch: getLine(doc.size-1).text.length};\n      var ch = pos.ch, linelen = getLine(pos.line).text.length;\n      if (ch == null || ch > linelen) return {line: pos.line, ch: linelen};\n      else if (ch < 0) return {line: pos.line, ch: 0};\n      else return pos;\n    }\n\n    function findPosH(dir, unit) {\n      var end = sel.inverted ? sel.from : sel.to, line = end.line, ch = end.ch;\n      var lineObj = getLine(line);\n      function findNextLine() {\n        for (var l = line + dir, e = dir < 0 ? -1 : doc.size; l != e; l += dir) {\n          var lo = getLine(l);\n          if (!lo.hidden) { line = l; lineObj = lo; return true; }\n        }\n      }\n      function moveOnce(boundToLine) {\n        if (ch == (dir < 0 ? 0 : lineObj.text.length)) {\n          if (!boundToLine && findNextLine()) ch = dir < 0 ? lineObj.text.length : 0;\n          else return false;\n        } else ch += dir;\n        return true;\n      }\n      if (unit == \"char\") moveOnce();\n      else if (unit == \"column\") moveOnce(true);\n      else if (unit == \"word\") {\n        var sawWord = false;\n        for (;;) {\n          if (dir < 0) if (!moveOnce()) break;\n          if (isWordChar(lineObj.text.charAt(ch))) sawWord = true;\n          else if (sawWord) {if (dir < 0) {dir = 1; moveOnce();} break;}\n          if (dir > 0) if (!moveOnce()) break;\n        }\n      }\n      return {line: line, ch: ch};\n    }\n    function moveH(dir, unit) {\n      var pos = dir < 0 ? sel.from : sel.to;\n      if (shiftSelecting || posEq(sel.from, sel.to)) pos = findPosH(dir, unit);\n      setCursor(pos.line, pos.ch, true);\n    }\n    function deleteH(dir, unit) {\n      if (!posEq(sel.from, sel.to)) replaceRange(\"\", sel.from, sel.to);\n      else if (dir < 0) replaceRange(\"\", findPosH(dir, unit), sel.to);\n      else replaceRange(\"\", sel.from, findPosH(dir, unit));\n      userSelChange = true;\n    }\n    var goalColumn = null;\n    function moveV(dir, unit) {\n      var dist = 0, pos = localCoords(sel.inverted ? sel.from : sel.to, true);\n      if (goalColumn != null) pos.x = goalColumn;\n      if (unit == \"page\") dist = Math.min(scroller.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      else if (unit == \"line\") dist = textHeight();\n      var target = coordsChar(pos.x, pos.y + dist * dir + 2);\n      if (unit == \"page\") scroller.scrollTop += localCoords(target, true).y - pos.y;\n      setCursor(target.line, target.ch, true);\n      goalColumn = pos.x;\n    }\n\n    function selectWordAt(pos) {\n      var line = getLine(pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      while (start > 0 && isWordChar(line.charAt(start - 1))) --start;\n      while (end < line.length && isWordChar(line.charAt(end))) ++end;\n      setSelectionUser({line: pos.line, ch: start}, {line: pos.line, ch: end});\n    }\n    function selectLine(line) {\n      setSelectionUser({line: line, ch: 0}, clipPos({line: line + 1, ch: 0}));\n    }\n    function indentSelected(mode) {\n      if (posEq(sel.from, sel.to)) return indentLine(sel.from.line, mode);\n      var e = sel.to.line - (sel.to.ch ? 0 : 1);\n      for (var i = sel.from.line; i <= e; ++i) indentLine(i, mode);\n    }\n\n    function indentLine(n, how) {\n      if (!how) how = \"add\";\n      if (how == \"smart\") {\n        if (!mode.indent) how = \"prev\";\n        else var state = getStateBefore(n);\n      }\n\n      var line = getLine(n), curSpace = line.indentation(options.tabSize),\n          curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n      if (how == \"prev\") {\n        if (n) indentation = getLine(n-1).indentation(options.tabSize);\n        else indentation = 0;\n      }\n      else if (how == \"smart\") indentation = mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      else if (how == \"add\") indentation = curSpace + options.indentUnit;\n      else if (how == \"subtract\") indentation = curSpace - options.indentUnit;\n      indentation = Math.max(0, indentation);\n      var diff = indentation - curSpace;\n\n      if (!diff) {\n        if (sel.from.line != n && sel.to.line != n) return;\n        var indentString = curSpaceString;\n      }\n      else {\n        var indentString = \"\", pos = 0;\n        if (options.indentWithTabs)\n          for (var i = Math.floor(indentation / options.tabSize); i; --i) {pos += options.tabSize; indentString += \"\\t\";}\n        while (pos < indentation) {++pos; indentString += \" \";}\n      }\n\n      replaceRange(indentString, {line: n, ch: 0}, {line: n, ch: curSpaceString.length});\n    }\n\n    function loadMode() {\n      mode = CodeMirror.getMode(options, options.mode);\n      doc.iter(0, doc.size, function(line) { line.stateAfter = null; });\n      work = [0];\n      startWorker();\n    }\n    function gutterChanged() {\n      var visible = options.gutter || options.lineNumbers;\n      gutter.style.display = visible ? \"\" : \"none\";\n      if (visible) gutterDirty = true;\n      else lineDiv.parentNode.style.marginLeft = 0;\n    }\n    function wrappingChanged(from, to) {\n      if (options.lineWrapping) {\n        wrapper.className += \" CodeMirror-wrap\";\n        var perLine = scroller.clientWidth / charWidth() - 3;\n        doc.iter(0, doc.size, function(line) {\n          if (line.hidden) return;\n          var guess = Math.ceil(line.text.length / perLine) || 1;\n          if (guess != 1) updateLineHeight(line, guess);\n        });\n        lineSpace.style.width = code.style.width = \"\";\n      } else {\n        wrapper.className = wrapper.className.replace(\" CodeMirror-wrap\", \"\");\n        maxWidth = null; maxLine = \"\";\n        doc.iter(0, doc.size, function(line) {\n          if (line.height != 1 && !line.hidden) updateLineHeight(line, 1);\n          if (line.text.length > maxLine.length) maxLine = line.text;\n        });\n      }\n      changes.push({from: 0, to: doc.size});\n    }\n    function makeTab(col) {\n      var w = options.tabSize - col % options.tabSize, cached = tabCache[w];\n      if (cached) return cached;\n      for (var str = \'<span class=\"cm-tab\">\', i = 0; i < w; ++i) str += \" \";\n      return (tabCache[w] = {html: str + \"</span>\", width: w});\n    }\n    function themeChanged() {\n      scroller.className = scroller.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n        options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    }\n    function keyMapChanged() {\n      var style = keyMap[options.keyMap].style;\n      wrapper.className = wrapper.className.replace(/\\s*cm-keymap-\\S+/g, \"\") +\n        (style ? \" cm-keymap-\" + style : \"\");\n    }\n\n    function TextMarker() { this.set = []; }\n    TextMarker.prototype.clear = operation(function() {\n      var min = Infinity, max = -Infinity;\n      for (var i = 0, e = this.set.length; i < e; ++i) {\n        var line = this.set[i], mk = line.marked;\n        if (!mk || !line.parent) continue;\n        var lineN = lineNo(line);\n        min = Math.min(min, lineN); max = Math.max(max, lineN);\n        for (var j = 0; j < mk.length; ++j)\n          if (mk[j].marker == this) mk.splice(j--, 1);\n      }\n      if (min != Infinity)\n        changes.push({from: min, to: max + 1});\n    });\n    TextMarker.prototype.find = function() {\n      var from, to;\n      for (var i = 0, e = this.set.length; i < e; ++i) {\n        var line = this.set[i], mk = line.marked;\n        for (var j = 0; j < mk.length; ++j) {\n          var mark = mk[j];\n          if (mark.marker == this) {\n            if (mark.from != null || mark.to != null) {\n              var found = lineNo(line);\n              if (found != null) {\n                if (mark.from != null) from = {line: found, ch: mark.from};\n                if (mark.to != null) to = {line: found, ch: mark.to};\n              }\n            }\n          }\n        }\n      }\n      return {from: from, to: to};\n    };\n\n    function markText(from, to, className) {\n      from = clipPos(from); to = clipPos(to);\n      var tm = new TextMarker();\n      if (!posLess(from, to)) return tm;\n      function add(line, from, to, className) {\n        getLine(line).addMark(new MarkedText(from, to, className, tm));\n      }\n      if (from.line == to.line) add(from.line, from.ch, to.ch, className);\n      else {\n        add(from.line, from.ch, null, className);\n        for (var i = from.line + 1, e = to.line; i < e; ++i)\n          add(i, null, null, className);\n        add(to.line, null, to.ch, className);\n      }\n      changes.push({from: from.line, to: to.line + 1});\n      return tm;\n    }\n\n    function setBookmark(pos) {\n      pos = clipPos(pos);\n      var bm = new Bookmark(pos.ch);\n      getLine(pos.line).addMark(bm);\n      return bm;\n    }\n\n    function findMarksAt(pos) {\n      pos = clipPos(pos);\n      var markers = [], marked = getLine(pos.line).marked;\n      if (!marked) return markers;\n      for (var i = 0, e = marked.length; i < e; ++i) {\n        var m = marked[i];\n        if ((m.from == null || m.from <= pos.ch) &&\n            (m.to == null || m.to >= pos.ch))\n          markers.push(m.marker || m);\n      }\n      return markers;\n    }\n\n    function addGutterMarker(line, text, className) {\n      if (typeof line == \"number\") line = getLine(clipLine(line));\n      line.gutterMarker = {text: text, style: className};\n      gutterDirty = true;\n      return line;\n    }\n    function removeGutterMarker(line) {\n      if (typeof line == \"number\") line = getLine(clipLine(line));\n      line.gutterMarker = null;\n      gutterDirty = true;\n    }\n\n    function changeLine(handle, op) {\n      var no = handle, line = handle;\n      if (typeof handle == \"number\") line = getLine(clipLine(handle));\n      else no = lineNo(handle);\n      if (no == null) return null;\n      if (op(line, no)) changes.push({from: no, to: no + 1});\n      else return null;\n      return line;\n    }\n    function setLineClass(handle, className, bgClassName) {\n      return changeLine(handle, function(line) {\n        if (line.className != className || line.bgClassName != bgClassName) {\n          line.className = className;\n          line.bgClassName = bgClassName;\n          return true;\n        }\n      });\n    }\n    function setLineHidden(handle, hidden) {\n      return changeLine(handle, function(line, no) {\n        if (line.hidden != hidden) {\n          line.hidden = hidden;\n          if (!options.lineWrapping) {\n            var l = line.text;\n            if (hidden && l.length == maxLine.length) {\n              maxLengthChanged = true;\n            }\n            else if (!hidden && l.length > maxLine.length) {\n              maxLine = l; maxWidth = null;\n              maxLengthChanged = false;\n            }\n          }\n          updateLineHeight(line, hidden ? 0 : 1);\n          var fline = sel.from.line, tline = sel.to.line;\n          if (hidden && (fline == no || tline == no)) {\n            var from = fline == no ? skipHidden({line: fline, ch: 0}, fline, 0) : sel.from;\n            var to = tline == no ? skipHidden({line: tline, ch: 0}, tline, 0) : sel.to;\n            // Can\'t hide the last visible line, we\'d have no place to put the cursor\n            if (!to) return;\n            setSelection(from, to);\n          }\n          return (gutterDirty = true);\n        }\n      });\n    }\n\n    function lineInfo(line) {\n      if (typeof line == \"number\") {\n        if (!isLine(line)) return null;\n        var n = line;\n        line = getLine(line);\n        if (!line) return null;\n      }\n      else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      var marker = line.gutterMarker;\n      return {line: n, handle: line, text: line.text, markerText: marker && marker.text,\n              markerClass: marker && marker.style, lineClass: line.className, bgClass: line.bgClassName};\n    }\n\n    function stringWidth(str) {\n      measure.innerHTML = \"<pre><span>x</span></pre>\";\n      measure.firstChild.firstChild.firstChild.nodeValue = str;\n      return measure.firstChild.firstChild.offsetWidth || 10;\n    }\n    // These are used to go from pixel positions to character\n    // positions, taking varying character widths into account.\n    function charFromX(line, x) {\n      if (x <= 0) return 0;\n      var lineObj = getLine(line), text = lineObj.text;\n      function getX(len) {\n        return measureLine(lineObj, len).left;\n      }\n      var from = 0, fromX = 0, to = text.length, toX;\n      // Guess a suitable upper bound for our search.\n      var estimated = Math.min(to, Math.ceil(x / charWidth()));\n      for (;;) {\n        var estX = getX(estimated);\n        if (estX <= x && estimated < to) estimated = Math.min(to, Math.ceil(estimated * 1.2));\n        else {toX = estX; to = estimated; break;}\n      }\n      if (x > toX) return to;\n      // Try to guess a suitable lower bound as well.\n      estimated = Math.floor(to * 0.8); estX = getX(estimated);\n      if (estX < x) {from = estimated; fromX = estX;}\n      // Do a binary search between these bounds.\n      for (;;) {\n        if (to - from <= 1) return (toX - x > x - fromX) ? from : to;\n        var middle = Math.ceil((from + to) / 2), middleX = getX(middle);\n        if (middleX > x) {to = middle; toX = middleX;}\n        else {from = middle; fromX = middleX;}\n      }\n    }\n\n    var tempId = \"CodeMirror-temp-\" + Math.floor(Math.random() * 0xffffff).toString(16);\n    function measureLine(line, ch) {\n      if (ch == 0) return {top: 0, left: 0};\n      var wbr = options.lineWrapping && ch < line.text.length &&\n                spanAffectsWrapping.test(line.text.slice(ch - 1, ch + 1));\n      measure.innerHTML = \"<pre>\" + line.getHTML(makeTab, ch, tempId, wbr) + \"</pre>\";\n      var elt = document.getElementById(tempId);\n      var top = elt.offsetTop, left = elt.offsetLeft;\n      // Older IEs report zero offsets for spans directly after a wrap\n      if (ie && top == 0 && left == 0) {\n        var backup = document.createElement(\"span\");\n        backup.innerHTML = \"x\";\n        elt.parentNode.insertBefore(backup, elt.nextSibling);\n        top = backup.offsetTop;\n      }\n      return {top: top, left: left};\n    }\n    function localCoords(pos, inLineWrap) {\n      var x, lh = textHeight(), y = lh * (heightAtLine(doc, pos.line) - (inLineWrap ? displayOffset : 0));\n      if (pos.ch == 0) x = 0;\n      else {\n        var sp = measureLine(getLine(pos.line), pos.ch);\n        x = sp.left;\n        if (options.lineWrapping) y += Math.max(0, sp.top);\n      }\n      return {x: x, y: y, yBot: y + lh};\n    }\n    // Coords must be lineSpace-local\n    function coordsChar(x, y) {\n      if (y < 0) y = 0;\n      var th = textHeight(), cw = charWidth(), heightPos = displayOffset + Math.floor(y / th);\n      var lineNo = lineAtHeight(doc, heightPos);\n      if (lineNo >= doc.size) return {line: doc.size - 1, ch: getLine(doc.size - 1).text.length};\n      var lineObj = getLine(lineNo), text = lineObj.text;\n      var tw = options.lineWrapping, innerOff = tw ? heightPos - heightAtLine(doc, lineNo) : 0;\n      if (x <= 0 && innerOff == 0) return {line: lineNo, ch: 0};\n      function getX(len) {\n        var sp = measureLine(lineObj, len);\n        if (tw) {\n          var off = Math.round(sp.top / th);\n          return Math.max(0, sp.left + (off - innerOff) * scroller.clientWidth);\n        }\n        return sp.left;\n      }\n      var from = 0, fromX = 0, to = text.length, toX;\n      // Guess a suitable upper bound for our search.\n      var estimated = Math.min(to, Math.ceil((x + innerOff * scroller.clientWidth * .9) / cw));\n      for (;;) {\n        var estX = getX(estimated);\n        if (estX <= x && estimated < to) estimated = Math.min(to, Math.ceil(estimated * 1.2));\n        else {toX = estX; to = estimated; break;}\n      }\n      if (x > toX) return {line: lineNo, ch: to};\n      // Try to guess a suitable lower bound as well.\n      estimated = Math.floor(to * 0.8); estX = getX(estimated);\n      if (estX < x) {from = estimated; fromX = estX;}\n      // Do a binary search between these bounds.\n      for (;;) {\n        if (to - from <= 1) return {line: lineNo, ch: (toX - x > x - fromX) ? from : to};\n        var middle = Math.ceil((from + to) / 2), middleX = getX(middle);\n        if (middleX > x) {to = middle; toX = middleX;}\n        else {from = middle; fromX = middleX;}\n      }\n    }\n    function pageCoords(pos) {\n      var local = localCoords(pos, true), off = eltOffset(lineSpace);\n      return {x: off.left + local.x, y: off.top + local.y, yBot: off.top + local.yBot};\n    }\n\n    var cachedHeight, cachedHeightFor, measureText;\n    function textHeight() {\n      if (measureText == null) {\n        measureText = \"<pre>\";\n        for (var i = 0; i < 49; ++i) measureText += \"x<br/>\";\n        measureText += \"x</pre>\";\n      }\n      var offsetHeight = lineDiv.clientHeight;\n      if (offsetHeight == cachedHeightFor) return cachedHeight;\n      cachedHeightFor = offsetHeight;\n      measure.innerHTML = measureText;\n      cachedHeight = measure.firstChild.offsetHeight / 50 || 1;\n      measure.innerHTML = \"\";\n      return cachedHeight;\n    }\n    var cachedWidth, cachedWidthFor = 0;\n    function charWidth() {\n      if (scroller.clientWidth == cachedWidthFor) return cachedWidth;\n      cachedWidthFor = scroller.clientWidth;\n      return (cachedWidth = stringWidth(\"x\"));\n    }\n    function paddingTop() {return lineSpace.offsetTop;}\n    function paddingLeft() {return lineSpace.offsetLeft;}\n\n    function posFromMouse(e, liberal) {\n      var offW = eltOffset(scroller, true), x, y;\n      // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n      try { x = e.clientX; y = e.clientY; } catch (e) { return null; }\n      // This is a mess of a heuristic to try and determine whether a\n      // scroll-bar was clicked or not, and to return null if one was\n      // (and !liberal).\n      if (!liberal && (x - offW.left > scroller.clientWidth || y - offW.top > scroller.clientHeight))\n        return null;\n      var offL = eltOffset(lineSpace, true);\n      return coordsChar(x - offL.left, y - offL.top);\n    }\n    function onContextMenu(e) {\n      var pos = posFromMouse(e), scrollPos = scroller.scrollTop;\n      if (!pos || window.opera) return; // Opera is difficult.\n      if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))\n        operation(setCursor)(pos.line, pos.ch);\n\n      var oldCSS = input.style.cssText;\n      inputDiv.style.position = \"absolute\";\n      input.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n        \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: white; \" +\n        \"border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n      leaveInputAlone = true;\n      var val = input.value = getSelection();\n      focusInput();\n      selectInput(input);\n      function rehide() {\n        var newVal = splitLines(input.value).join(\"\\n\");\n        if (newVal != val) operation(replaceSelection)(newVal, \"end\");\n        inputDiv.style.position = \"relative\";\n        input.style.cssText = oldCSS;\n        if (ie_lt9) scroller.scrollTop = scrollPos;\n        leaveInputAlone = false;\n        resetInput(true);\n        slowPoll();\n      }\n\n      if (gecko) {\n        e_stop(e);\n        var mouseup = connect(window, \"mouseup\", function() {\n          mouseup();\n          setTimeout(rehide, 20);\n        }, true);\n      } else {\n        setTimeout(rehide, 50);\n      }\n    }\n\n    // Cursor-blinking\n    function restartBlink() {\n      clearInterval(blinker);\n      var on = true;\n      cursor.style.visibility = \"\";\n      blinker = setInterval(function() {\n        cursor.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, 650);\n    }\n\n    var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n    function matchBrackets(autoclear) {\n      var head = sel.inverted ? sel.from : sel.to, line = getLine(head.line), pos = head.ch - 1;\n      var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];\n      if (!match) return;\n      var ch = match.charAt(0), forward = match.charAt(1) == \">\", d = forward ? 1 : -1, st = line.styles;\n      for (var off = pos + 1, i = 0, e = st.length; i < e; i+=2)\n        if ((off -= st[i].length) <= 0) {var style = st[i+1]; break;}\n\n      var stack = [line.text.charAt(pos)], re = /[(){}[\\]]/;\n      function scan(line, from, to) {\n        if (!line.text) return;\n        var st = line.styles, pos = forward ? 0 : line.text.length - 1, cur;\n        for (var i = forward ? 0 : st.length - 2, e = forward ? st.length : -2; i != e; i += 2*d) {\n          var text = st[i];\n          if (st[i+1] != null && st[i+1] != style) {pos += d * text.length; continue;}\n          for (var j = forward ? 0 : text.length - 1, te = forward ? text.length : -1; j != te; j += d, pos+=d) {\n            if (pos >= from && pos < to && re.test(cur = text.charAt(j))) {\n              var match = matching[cur];\n              if (match.charAt(1) == \">\" == forward) stack.push(cur);\n              else if (stack.pop() != match.charAt(0)) return {pos: pos, match: false};\n              else if (!stack.length) return {pos: pos, match: true};\n            }\n          }\n        }\n      }\n      for (var i = head.line, e = forward ? Math.min(i + 100, doc.size) : Math.max(-1, i - 100); i != e; i+=d) {\n        var line = getLine(i), first = i == head.line;\n        var found = scan(line, first && forward ? pos + 1 : 0, first && !forward ? pos : line.text.length);\n        if (found) break;\n      }\n      if (!found) found = {pos: null, match: false};\n      var style = found.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n      var one = markText({line: head.line, ch: pos}, {line: head.line, ch: pos+1}, style),\n          two = found.pos != null && markText({line: i, ch: found.pos}, {line: i, ch: found.pos + 1}, style);\n      var clear = operation(function(){one.clear(); two && two.clear();});\n      if (autoclear) setTimeout(clear, 800);\n      else bracketHighlighted = clear;\n    }\n\n    // Finds the line to start with when starting a parse. Tries to\n    // find a line with a stateAfter, so that it can start with a\n    // valid state. If that fails, it returns the line with the\n    // smallest indentation, which tends to need the least context to\n    // parse correctly.\n    function findStartLine(n) {\n      var minindent, minline;\n      for (var search = n, lim = n - 40; search > lim; --search) {\n        if (search == 0) return 0;\n        var line = getLine(search-1);\n        if (line.stateAfter) return search;\n        var indented = line.indentation(options.tabSize);\n        if (minline == null || minindent > indented) {\n          minline = search - 1;\n          minindent = indented;\n        }\n      }\n      return minline;\n    }\n    function getStateBefore(n) {\n      var start = findStartLine(n), state = start && getLine(start-1).stateAfter;\n      if (!state) state = startState(mode);\n      else state = copyState(mode, state);\n      doc.iter(start, n, function(line) {\n        line.highlight(mode, state, options.tabSize);\n        line.stateAfter = copyState(mode, state);\n      });\n      if (start < n) changes.push({from: start, to: n});\n      if (n < doc.size && !getLine(n).stateAfter) work.push(n);\n      return state;\n    }\n    function highlightLines(start, end) {\n      var state = getStateBefore(start);\n      doc.iter(start, end, function(line) {\n        line.highlight(mode, state, options.tabSize);\n        line.stateAfter = copyState(mode, state);\n      });\n    }\n    function highlightWorker() {\n      var end = +new Date + options.workTime;\n      var foundWork = work.length;\n      while (work.length) {\n        if (!getLine(showingFrom).stateAfter) var task = showingFrom;\n        else var task = work.pop();\n        if (task >= doc.size) continue;\n        var start = findStartLine(task), state = start && getLine(start-1).stateAfter;\n        if (state) state = copyState(mode, state);\n        else state = startState(mode);\n\n        var unchanged = 0, compare = mode.compareStates, realChange = false,\n            i = start, bail = false;\n        doc.iter(i, doc.size, function(line) {\n          var hadState = line.stateAfter;\n          if (+new Date > end) {\n            work.push(i);\n            startWorker(options.workDelay);\n            if (realChange) changes.push({from: task, to: i + 1});\n            return (bail = true);\n          }\n          var changed = line.highlight(mode, state, options.tabSize);\n          if (changed) realChange = true;\n          line.stateAfter = copyState(mode, state);\n          var done = null;\n          if (compare) {\n            var same = hadState && compare(hadState, state);\n            if (same != Pass) done = !!same;\n          }\n          if (done == null) {\n            if (changed !== false || !hadState) unchanged = 0;\n            else if (++unchanged > 3 && (!mode.indent || mode.indent(hadState, \"\") == mode.indent(state, \"\")))\n              done = true;\n          }\n          if (done) return true;\n          ++i;\n        });\n        if (bail) return;\n        if (realChange) changes.push({from: task, to: i + 1});\n      }\n      if (foundWork && options.onHighlightComplete)\n        options.onHighlightComplete(instance);\n    }\n    function startWorker(time) {\n      if (!work.length) return;\n      highlight.set(time, operation(highlightWorker));\n    }\n\n    // Operations are used to wrap changes in such a way that each\n    // change won\'t have to update the cursor and display (which would\n    // be awkward, slow, and error-prone), but instead updates are\n    // batched and then all combined and executed at once.\n    function startOperation() {\n      updateInput = userSelChange = textChanged = null;\n      changes = []; selectionChanged = false; callbacks = [];\n    }\n    function endOperation() {\n      var reScroll = false, updated;\n      if (maxLengthChanged) computeMaxLength();\n      if (selectionChanged) reScroll = !scrollCursorIntoView();\n      if (changes.length) updated = updateDisplay(changes, true);\n      else {\n        if (selectionChanged) updateSelection();\n        if (gutterDirty) updateGutter();\n      }\n      if (reScroll) scrollCursorIntoView();\n      if (selectionChanged) {scrollEditorIntoView(); restartBlink();}\n\n      if (focused && !leaveInputAlone &&\n          (updateInput === true || (updateInput !== false && selectionChanged)))\n        resetInput(userSelChange);\n\n      if (selectionChanged && options.matchBrackets)\n        setTimeout(operation(function() {\n          if (bracketHighlighted) {bracketHighlighted(); bracketHighlighted = null;}\n          if (posEq(sel.from, sel.to)) matchBrackets(false);\n        }), 20);\n      var tc = textChanged, cbs = callbacks; // these can be reset by callbacks\n      if (selectionChanged && options.onCursorActivity)\n        options.onCursorActivity(instance);\n      if (tc && options.onChange && instance)\n        options.onChange(instance, tc);\n      for (var i = 0; i < cbs.length; ++i) cbs[i](instance);\n      if (updated && options.onUpdate) options.onUpdate(instance);\n    }\n    var nestedOperation = 0;\n    function operation(f) {\n      return function() {\n        if (!nestedOperation++) startOperation();\n        try {var result = f.apply(this, arguments);}\n        finally {if (!--nestedOperation) endOperation();}\n        return result;\n      };\n    }\n\n    function compoundChange(f) {\n      history.startCompound();\n      try { return f(); } finally { history.endCompound(); }\n    }\n\n    for (var ext in extensions)\n      if (extensions.propertyIsEnumerable(ext) &&\n          !instance.propertyIsEnumerable(ext))\n        instance[ext] = extensions[ext];\n    return instance;\n  } // (end of function CodeMirror)\n\n  // The default configuration options.\n  CodeMirror.defaults = {\n    value: \"\",\n    mode: null,\n    theme: \"default\",\n    indentUnit: 2,\n    indentWithTabs: false,\n    smartIndent: true,\n    tabSize: 4,\n    keyMap: \"default\",\n    extraKeys: null,\n    electricChars: true,\n    autoClearEmptyLines: false,\n    onKeyEvent: null,\n    onDragEvent: null,\n    lineWrapping: false,\n    lineNumbers: false,\n    gutter: false,\n    fixedGutter: false,\n    firstLineNumber: 1,\n    readOnly: false,\n    dragDrop: true,\n    onChange: null,\n    onCursorActivity: null,\n    onGutterClick: null,\n    onHighlightComplete: null,\n    onUpdate: null,\n    onFocus: null, onBlur: null, onScroll: null,\n    matchBrackets: false,\n    workTime: 100,\n    workDelay: 200,\n    pollInterval: 100,\n    undoDepth: 40,\n    tabindex: null,\n    autofocus: null\n  };\n\n  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\n  var mac = ios || /Mac/.test(navigator.platform);\n  var win = /Win/.test(navigator.platform);\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2) {\n      mode.dependencies = [];\n      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);\n    }\n    modes[name] = mode;\n  };\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec))\n      spec = mimeModes[spec];\n    else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec))\n      return CodeMirror.resolveMode(\"application/xml\");\n    if (typeof spec == \"string\") return {name: spec};\n    else return spec || {name: \"null\"};\n  };\n  CodeMirror.getMode = function(options, spec) {\n    var spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n    return mfactory(options, spec);\n  };\n  CodeMirror.listModes = function() {\n    var list = [];\n    for (var m in modes)\n      if (modes.propertyIsEnumerable(m)) list.push(m);\n    return list;\n  };\n  CodeMirror.listMIMEs = function() {\n    var list = [];\n    for (var m in mimeModes)\n      if (mimeModes.propertyIsEnumerable(m)) list.push({mime: m, mode: mimeModes[m]});\n    return list;\n  };\n\n  var extensions = CodeMirror.extensions = {};\n  CodeMirror.defineExtension = function(name, func) {\n    extensions[name] = func;\n  };\n\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection({line: 0, ch: 0}, {line: cm.lineCount() - 1});},\n    killLine: function(cm) {\n      var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);\n      if (!sel && cm.getLine(from.line).length == from.ch) cm.replaceRange(\"\", from, {line: from.line + 1, ch: 0});\n      else cm.replaceRange(\"\", from, sel ? to : {line: from.line});\n    },\n    deleteLine: function(cm) {var l = cm.getCursor().line; cm.replaceRange(\"\", {line: l, ch: 0}, {line: l});},\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    goDocStart: function(cm) {cm.setCursor(0, 0, true);},\n    goDocEnd: function(cm) {cm.setSelection({line: cm.lineCount() - 1}, null, true);},\n    goLineStart: function(cm) {cm.setCursor(cm.getCursor().line, 0, true);},\n    goLineStartSmart: function(cm) {\n      var cur = cm.getCursor();\n      var text = cm.getLine(cur.line), firstNonWS = Math.max(0, text.search(/\\S/));\n      cm.setCursor(cur.line, cur.ch <= firstNonWS && cur.ch ? 0 : firstNonWS, true);\n    },\n    goLineEnd: function(cm) {cm.setSelection({line: cm.getCursor().line}, null, true);},\n    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n    delCharLeft: function(cm) {cm.deleteH(-1, \"char\");},\n    delCharRight: function(cm) {cm.deleteH(1, \"char\");},\n    delWordLeft: function(cm) {cm.deleteH(-1, \"word\");},\n    delWordRight: function(cm) {cm.deleteH(1, \"word\");},\n    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n    indentMore: function(cm) {cm.indentSelection(\"add\");},\n    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n    insertTab: function(cm) {cm.replaceSelection(\"\\t\", \"end\");},\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n      else cm.replaceSelection(\"\\t\", \"end\");\n    },\n    transposeChars: function(cm) {\n      var cur = cm.getCursor(), line = cm.getLine(cur.line);\n      if (cur.ch > 0 && cur.ch < line.length - 1)\n        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),\n                        {line: cur.line, ch: cur.ch - 1}, {line: cur.line, ch: cur.ch + 1});\n    },\n    newlineAndIndent: function(cm) {\n      cm.replaceSelection(\"\\n\", \"end\");\n      cm.indentLine(cm.getCursor().line);\n    },\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n  var keyMap = CodeMirror.keyMap = {};\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharRight\", \"Backspace\": \"delCharLeft\", \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\"\n  };\n  // Note that the save and find-related commands aren\'t defined by\n  // default. Unknown commands are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Alt-Up\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Down\": \"goDocEnd\",\n    \"Ctrl-Left\": \"goWordLeft\", \"Ctrl-Right\": \"goWordRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delWordLeft\", \"Ctrl-Delete\": \"delWordRight\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    fallthrough: \"basic\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goWordLeft\",\n    \"Alt-Right\": \"goWordRight\", \"Cmd-Left\": \"goLineStart\", \"Cmd-Right\": \"goLineEnd\", \"Alt-Backspace\": \"delWordLeft\",\n    \"Ctrl-Alt-Backspace\": \"delWordRight\", \"Alt-Delete\": \"delWordRight\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\",\n    fallthrough: [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageUp\", \"Shift-Ctrl-V\": \"goPageDown\", \"Ctrl-D\": \"delCharRight\", \"Ctrl-H\": \"delCharLeft\",\n    \"Alt-D\": \"delWordRight\", \"Alt-Backspace\": \"delWordLeft\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n  };\n\n  function getKeyMap(val) {\n    if (typeof val == \"string\") return keyMap[val];\n    else return val;\n  }\n  function lookupKey(name, extraMap, map, handle, stop) {\n    function lookup(map) {\n      map = getKeyMap(map);\n      var found = map[name];\n      if (found != null && handle(found)) return true;\n      if (map.nofallthrough) {\n        if (stop) stop();\n        return true;\n      }\n      var fallthrough = map.fallthrough;\n      if (fallthrough == null) return false;\n      if (Object.prototype.toString.call(fallthrough) != \"[object Array]\")\n        return lookup(fallthrough);\n      for (var i = 0, e = fallthrough.length; i < e; ++i) {\n        if (lookup(fallthrough[i])) return true;\n      }\n      return false;\n    }\n    if (extraMap && lookup(extraMap)) return true;\n    return lookup(map);\n  }\n  function isModifierKey(event) {\n    var name = keyNames[e_prop(event, \"keyCode\")];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  }\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    if (!options) options = {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabindex)\n      options.tabindex = textarea.tabindex;\n    if (options.autofocus == null && textarea.getAttribute(\"autofocus\") != null)\n      options.autofocus = true;\n\n    function save() {textarea.value = instance.getValue();}\n    if (textarea.form) {\n      // Deplorable hack to make the submit method do the right thing.\n      var rmSubmit = connect(textarea.form, \"submit\", save, true);\n      if (typeof textarea.form.submit == \"function\") {\n        var realSubmit = textarea.form.submit;\n        function wrappedSubmit() {\n          save();\n          textarea.form.submit = realSubmit;\n          textarea.form.submit();\n          textarea.form.submit = wrappedSubmit;\n        }\n        textarea.form.submit = wrappedSubmit;\n      }\n    }\n\n    textarea.style.display = \"none\";\n    var instance = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    instance.save = save;\n    instance.getTextArea = function() { return textarea; };\n    instance.toTextArea = function() {\n      save();\n      textarea.parentNode.removeChild(instance.getWrapperElement());\n      textarea.style.display = \"\";\n      if (textarea.form) {\n        rmSubmit();\n        if (typeof textarea.form.submit == \"function\")\n          textarea.form.submit = realSubmit;\n      }\n    };\n    return instance;\n  };\n\n  // Utility functions for working with state. Exported because modes\n  // sometimes need to do this.\n  function copyState(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  }\n  CodeMirror.copyState = copyState;\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  }\n  CodeMirror.startState = startState;\n\n  // The character stream used by a mode\'s parser.\n  function StringStream(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n  }\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == 0;},\n    peek: function() {return this.string.charAt(this.pos);},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {return countColumn(this.string, this.start, this.tabSize);},\n    indentation: function() {return countColumn(this.string, null, this.tabSize);},\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        function cased(str) {return caseInsensitive ? str.toLowerCase() : str;}\n        if (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      }\n      else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);}\n  };\n  CodeMirror.StringStream = StringStream;\n\n  function MarkedText(from, to, className, marker) {\n    this.from = from; this.to = to; this.style = className; this.marker = marker;\n  }\n  MarkedText.prototype = {\n    attach: function(line) { this.marker.set.push(line); },\n    detach: function(line) {\n      var ix = indexOf(this.marker.set, line);\n      if (ix > -1) this.marker.set.splice(ix, 1);\n    },\n    split: function(pos, lenBefore) {\n      if (this.to <= pos && this.to != null) return null;\n      var from = this.from < pos || this.from == null ? null : this.from - pos + lenBefore;\n      var to = this.to == null ? null : this.to - pos + lenBefore;\n      return new MarkedText(from, to, this.style, this.marker);\n    },\n    dup: function() { return new MarkedText(null, null, this.style, this.marker); },\n    clipTo: function(fromOpen, from, toOpen, to, diff) {\n      if (fromOpen && to > this.from && (to < this.to || this.to == null))\n        this.from = null;\n      else if (this.from != null && this.from >= from)\n        this.from = Math.max(to, this.from) + diff;\n      if (toOpen && (from < this.to || this.to == null) && (from > this.from || this.from == null))\n        this.to = null;\n      else if (this.to != null && this.to > from)\n        this.to = to < this.to ? this.to + diff : from;\n    },\n    isDead: function() { return this.from != null && this.to != null && this.from >= this.to; },\n    sameSet: function(x) { return this.marker == x.marker; }\n  };\n\n  function Bookmark(pos) {\n    this.from = pos; this.to = pos; this.line = null;\n  }\n  Bookmark.prototype = {\n    attach: function(line) { this.line = line; },\n    detach: function(line) { if (this.line == line) this.line = null; },\n    split: function(pos, lenBefore) {\n      if (pos < this.from) {\n        this.from = this.to = (this.from - pos) + lenBefore;\n        return this;\n      }\n    },\n    isDead: function() { return this.from > this.to; },\n    clipTo: function(fromOpen, from, toOpen, to, diff) {\n      if ((fromOpen || from < this.from) && (toOpen || to > this.to)) {\n        this.from = 0; this.to = -1;\n      } else if (this.from > from) {\n        this.from = this.to = Math.max(to, this.from) + diff;\n      }\n    },\n    sameSet: function(x) { return false; },\n    find: function() {\n      if (!this.line || !this.line.parent) return null;\n      return {line: lineNo(this.line), ch: this.from};\n    },\n    clear: function() {\n      if (this.line) {\n        var found = indexOf(this.line.marked, this);\n        if (found != -1) this.line.marked.splice(found, 1);\n        this.line = null;\n      }\n    }\n  };\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  function Line(text, styles) {\n    this.styles = styles || [text, null];\n    this.text = text;\n    this.height = 1;\n    this.marked = this.gutterMarker = this.className = this.bgClassName = this.handlers = null;\n    this.stateAfter = this.parent = this.hidden = null;\n  }\n  Line.inheritMarks = function(text, orig) {\n    var ln = new Line(text), mk = orig && orig.marked;\n    if (mk) {\n      for (var i = 0; i < mk.length; ++i) {\n        if (mk[i].to == null && mk[i].style) {\n          var newmk = ln.marked || (ln.marked = []), mark = mk[i];\n          var nmark = mark.dup(); newmk.push(nmark); nmark.attach(ln);\n        }\n      }\n    }\n    return ln;\n  }\n  Line.prototype = {\n    // Replace a piece of a line, keeping the styles around it intact.\n    replace: function(from, to_, text) {\n      var st = [], mk = this.marked, to = to_ == null ? this.text.length : to_;\n      copyStyles(0, from, this.styles, st);\n      if (text) st.push(text, null);\n      copyStyles(to, this.text.length, this.styles, st);\n      this.styles = st;\n      this.text = this.text.slice(0, from) + text + this.text.slice(to);\n      this.stateAfter = null;\n      if (mk) {\n        var diff = text.length - (to - from);\n        for (var i = 0; i < mk.length; ++i) {\n          var mark = mk[i];\n          mark.clipTo(from == null, from || 0, to_ == null, to, diff);\n          if (mark.isDead()) {mark.detach(this); mk.splice(i--, 1);}\n        }\n      }\n    },\n    // Split a part off a line, keeping styles and markers intact.\n    split: function(pos, textBefore) {\n      var st = [textBefore, null], mk = this.marked;\n      copyStyles(pos, this.text.length, this.styles, st);\n      var taken = new Line(textBefore + this.text.slice(pos), st);\n      if (mk) {\n        for (var i = 0; i < mk.length; ++i) {\n          var mark = mk[i];\n          var newmark = mark.split(pos, textBefore.length);\n          if (newmark) {\n            if (!taken.marked) taken.marked = [];\n            taken.marked.push(newmark); newmark.attach(taken);\n            if (newmark == mark) mk.splice(i--, 1);\n          }\n        }\n      }\n      return taken;\n    },\n    append: function(line) {\n      var mylen = this.text.length, mk = line.marked, mymk = this.marked;\n      this.text += line.text;\n      copyStyles(0, line.text.length, line.styles, this.styles);\n      if (mymk) {\n        for (var i = 0; i < mymk.length; ++i)\n          if (mymk[i].to == null) mymk[i].to = mylen;\n      }\n      if (mk && mk.length) {\n        if (!mymk) this.marked = mymk = [];\n        outer: for (var i = 0; i < mk.length; ++i) {\n          var mark = mk[i];\n          if (!mark.from) {\n            for (var j = 0; j < mymk.length; ++j) {\n              var mymark = mymk[j];\n              if (mymark.to == mylen && mymark.sameSet(mark)) {\n                mymark.to = mark.to == null ? null : mark.to + mylen;\n                if (mymark.isDead()) {\n                  mymark.detach(this);\n                  mk.splice(i--, 1);\n                }\n                continue outer;\n              }\n            }\n          }\n          mymk.push(mark);\n          mark.attach(this);\n          mark.from += mylen;\n          if (mark.to != null) mark.to += mylen;\n        }\n      }\n    },\n    fixMarkEnds: function(other) {\n      var mk = this.marked, omk = other.marked;\n      if (!mk) return;\n      for (var i = 0; i < mk.length; ++i) {\n        var mark = mk[i], close = mark.to == null;\n        if (close && omk) {\n          for (var j = 0; j < omk.length; ++j)\n            if (omk[j].sameSet(mark)) {close = false; break;}\n        }\n        if (close) mark.to = this.text.length;\n      }\n    },\n    fixMarkStarts: function() {\n      var mk = this.marked;\n      if (!mk) return;\n      for (var i = 0; i < mk.length; ++i)\n        if (mk[i].from == null) mk[i].from = 0;\n    },\n    addMark: function(mark) {\n      mark.attach(this);\n      if (this.marked == null) this.marked = [];\n      this.marked.push(mark);\n      this.marked.sort(function(a, b){return (a.from || 0) - (b.from || 0);});\n    },\n    // Run the given mode\'s parser over a line, update the styles\n    // array, which contains alternating fragments of text and CSS\n    // classes.\n    highlight: function(mode, state, tabSize) {\n      var stream = new StringStream(this.text, tabSize), st = this.styles, pos = 0;\n      var changed = false, curWord = st[0], prevWord;\n      if (this.text == \"\" && mode.blankLine) mode.blankLine(state);\n      while (!stream.eol()) {\n        var style = mode.token(stream, state);\n        var substr = this.text.slice(stream.start, stream.pos);\n        stream.start = stream.pos;\n        if (pos && st[pos-1] == style)\n          st[pos-2] += substr;\n        else if (substr) {\n          if (!changed && (st[pos+1] != style || (pos && st[pos-2] != prevWord))) changed = true;\n          st[pos++] = substr; st[pos++] = style;\n          prevWord = curWord; curWord = st[pos];\n        }\n        // Give up when line is ridiculously long\n        if (stream.pos > 5000) {\n          st[pos++] = this.text.slice(stream.pos); st[pos++] = null;\n          break;\n        }\n      }\n      if (st.length != pos) {st.length = pos; changed = true;}\n      if (pos && st[pos-2] != prevWord) changed = true;\n      // Short lines with simple highlights return null, and are\n      // counted as changed by the driver because they are likely to\n      // highlight the same way in various contexts.\n      return changed || (st.length < 5 && this.text.length < 10 ? null : false);\n    },\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(mode, state, ch) {\n      var txt = this.text, stream = new StringStream(txt);\n      while (stream.pos < ch && !stream.eol()) {\n        stream.start = stream.pos;\n        var style = mode.token(stream, state);\n      }\n      return {start: stream.start,\n              end: stream.pos,\n              string: stream.current(),\n              className: style || null,\n              state: state};\n    },\n    indentation: function(tabSize) {return countColumn(this.text, null, tabSize);},\n    // Produces an HTML fragment for the line, taking selection,\n    // marking, and highlighting into account.\n    getHTML: function(makeTab, wrapAt, wrapId, wrapWBR) {\n      var html = [], first = true, col = 0;\n      function span_(text, style) {\n        if (!text) return;\n        // Work around a bug where, in some compat modes, IE ignores leading spaces\n        if (first && ie && text.charAt(0) == \" \") text = \"\\u00a0\" + text.slice(1);\n        first = false;\n        if (text.indexOf(\"\\t\") == -1) {\n          col += text.length;\n          var escaped = htmlEscape(text);\n        } else {\n          var escaped = \"\";\n          for (var pos = 0;;) {\n            var idx = text.indexOf(\"\\t\", pos);\n            if (idx == -1) {\n              escaped += htmlEscape(text.slice(pos));\n              col += text.length - pos;\n              break;\n            } else {\n              col += idx - pos;\n              var tab = makeTab(col);\n              escaped += htmlEscape(text.slice(pos, idx)) + tab.html;\n              col += tab.width;\n              pos = idx + 1;\n            }\n          }\n        }\n        if (style) html.push(\'<span class=\"\', style, \'\">\', escaped, \"</span>\");\n        else html.push(escaped);\n      }\n      var span = span_;\n      if (wrapAt != null) {\n        var outPos = 0, open = \"<span id=\\\"\" + wrapId + \"\\\">\";\n        span = function(text, style) {\n          var l = text.length;\n          if (wrapAt >= outPos && wrapAt < outPos + l) {\n            if (wrapAt > outPos) {\n              span_(text.slice(0, wrapAt - outPos), style);\n              // See comment at the definition of spanAffectsWrapping\n              if (wrapWBR) html.push(\"<wbr>\");\n            }\n            html.push(open);\n            var cut = wrapAt - outPos;\n            span_(window.opera ? text.slice(cut, cut + 1) : text.slice(cut), style);\n            html.push(\"</span>\");\n            if (window.opera) span_(text.slice(cut + 1), style);\n            wrapAt--;\n            outPos += l;\n          } else {\n            outPos += l;\n            span_(text, style);\n            // Output empty wrapper when at end of line\n            if (outPos == wrapAt && outPos == len) html.push(open + \" </span>\");\n            // Stop outputting HTML when gone sufficiently far beyond measure\n            else if (outPos > wrapAt + 10 && /\\s/.test(text)) span = function(){};\n          }\n        }\n      }\n\n      var st = this.styles, allText = this.text, marked = this.marked;\n      var len = allText.length;\n      function styleToClass(style) {\n        if (!style) return null;\n        return \"cm-\" + style.replace(/ +/g, \" cm-\");\n      }\n\n      if (!allText && wrapAt == null) {\n        span(\" \");\n      } else if (!marked || !marked.length) {\n        for (var i = 0, ch = 0; ch < len; i+=2) {\n          var str = st[i], style = st[i+1], l = str.length;\n          if (ch + l > len) str = str.slice(0, len - ch);\n          ch += l;\n          span(str, styleToClass(style));\n        }\n      } else {\n        var pos = 0, i = 0, text = \"\", style, sg = 0;\n        var nextChange = marked[0].from || 0, marks = [], markpos = 0;\n        function advanceMarks() {\n          var m;\n          while (markpos < marked.length &&\n                 ((m = marked[markpos]).from == pos || m.from == null)) {\n            if (m.style != null) marks.push(m);\n            ++markpos;\n          }\n          nextChange = markpos < marked.length ? marked[markpos].from : Infinity;\n          for (var i = 0; i < marks.length; ++i) {\n            var to = marks[i].to || Infinity;\n            if (to == pos) marks.splice(i--, 1);\n            else nextChange = Math.min(to, nextChange);\n          }\n        }\n        var m = 0;\n        while (pos < len) {\n          if (nextChange == pos) advanceMarks();\n          var upto = Math.min(len, nextChange);\n          while (true) {\n            if (text) {\n              var end = pos + text.length;\n              var appliedStyle = style;\n              for (var j = 0; j < marks.length; ++j)\n                appliedStyle = (appliedStyle ? appliedStyle + \" \" : \"\") + marks[j].style;\n              span(end > upto ? text.slice(0, upto - pos) : text, appliedStyle);\n              if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n              pos = end;\n            }\n            text = st[i++]; style = styleToClass(st[i++]);\n          }\n        }\n      }\n      return html.join(\"\");\n    },\n    cleanUp: function() {\n      this.parent = null;\n      if (this.marked)\n        for (var i = 0, e = this.marked.length; i < e; ++i) this.marked[i].detach(this);\n    }\n  };\n  // Utility used by replace and split above\n  function copyStyles(from, to, source, dest) {\n    for (var i = 0, pos = 0, state = 0; pos < to; i+=2) {\n      var part = source[i], end = pos + part.length;\n      if (state == 0) {\n        if (end > from) dest.push(part.slice(from - pos, Math.min(part.length, to - pos)), source[i+1]);\n        if (end >= from) state = 1;\n      }\n      else if (state == 1) {\n        if (end > to) dest.push(part.slice(0, to - pos), source[i+1]);\n        else dest.push(part, source[i+1]);\n      }\n      pos = end;\n    }\n  }\n\n  // Data structure that holds the sequence of lines.\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    remove: function(at, n, callbacks) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        line.cleanUp();\n        if (line.handlers)\n          for (var j = 0; j < line.handlers.length; ++j) callbacks.push(line.handlers[j]);\n      }\n      this.lines.splice(at, n);\n    },\n    collapse: function(lines) {\n      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));\n    },\n    insertHeight: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;\n    },\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0, e = children.length; i < e; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    remove: function(at, n, callbacks) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.remove(at, rm, callbacks);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      if (this.size - n < 25) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);\n    },\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;\n      this.insertHeight(at, lines, height);\n    },\n    insertHeight: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertHeight(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iter: function(from, to, op) { this.iterN(from, to - from, op); },\n    iterN: function(at, n, op) {\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  function getLineAt(chunk, n) {\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0, e = chunk.children.length; ; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no;\n  }\n  function lineAtHeight(chunk, h) {\n    var n = 0;\n    outer: do {\n      for (var i = 0, e = chunk.children.length; i < e; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0, e = chunk.lines.length; i < e; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n  function heightAtLine(chunk, n) {\n    var h = 0;\n    outer: do {\n      for (var i = 0, e = chunk.children.length; i < e; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; continue outer; }\n        n -= sz;\n        h += child.height;\n      }\n      return h;\n    } while (!chunk.lines);\n    for (var i = 0; i < n; ++i) h += chunk.lines[i].height;\n    return h;\n  }\n\n  // The history object \'chunks\' changes that are made close together\n  // and at almost the same time into bigger undoable units.\n  function History() {\n    this.time = 0;\n    this.done = []; this.undone = [];\n    this.compound = 0;\n    this.closed = false;\n  }\n  History.prototype = {\n    addChange: function(start, added, old) {\n      this.undone.length = 0;\n      var time = +new Date, cur = this.done[this.done.length - 1], last = cur && cur[cur.length - 1];\n      var dtime = time - this.time;\n\n      if (this.compound && cur && !this.closed) {\n        cur.push({start: start, added: added, old: old});\n      } else if (dtime > 400 || !last || this.closed ||\n                 last.start > start + old.length || last.start + last.added < start) {\n        this.done.push([{start: start, added: added, old: old}]);\n        this.closed = false;\n      } else {\n        var startBefore = Math.max(0, last.start - start),\n            endAfter = Math.max(0, (start + old.length) - (last.start + last.added));\n        for (var i = startBefore; i > 0; --i) last.old.unshift(old[i - 1]);\n        for (var i = endAfter; i > 0; --i) last.old.push(old[old.length - i]);\n        if (startBefore) last.start = start;\n        last.added += added - (old.length - startBefore - endAfter);\n      }\n      this.time = time;\n    },\n    startCompound: function() {\n      if (!this.compound++) this.closed = true;\n    },\n    endCompound: function() {\n      if (!--this.compound) this.closed = true;\n    }\n  };\n\n  function stopMethod() {e_stop(this);}\n  // Ensure an event has a stop method.\n  function addStop(event) {\n    if (!event.stop) event.stop = stopMethod;\n    return event;\n  }\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    if (e.which) return e.which;\n    else if (e.button & 1) return 1;\n    else if (e.button & 2) return 3;\n    else if (e.button & 4) return 2;\n  }\n\n  // Allow 3rd-party code to override event properties by adding an override\n  // object to an event object.\n  function e_prop(e, prop) {\n    var overridden = e.override && e.override.hasOwnProperty(prop);\n    return overridden ? e.override[prop] : e[prop];\n  }\n\n  // Event handler registration. If disconnect is true, it\'ll return a\n  // function that unregisters the handler.\n  function connect(node, type, handler, disconnect) {\n    if (typeof node.addEventListener == \"function\") {\n      node.addEventListener(type, handler, false);\n      if (disconnect) return function() {node.removeEventListener(type, handler, false);};\n    }\n    else {\n      var wrapHandler = function(event) {handler(event || window.event);};\n      node.attachEvent(\"on\" + type, wrapHandler);\n      if (disconnect) return function() {node.detachEvent(\"on\" + type, wrapHandler);};\n    }\n  }\n  CodeMirror.connect = connect;\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};\n\n  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\n  var gecko = /gecko\\/\\d{7}/i.test(navigator.userAgent);\n  var ie = /MSIE \\d/.test(navigator.userAgent);\n  var ie_lt9 = /MSIE [1-8]\\b/.test(navigator.userAgent);\n  var quirksMode = ie && document.documentMode == 5;\n  var webkit = /WebKit\\//.test(navigator.userAgent);\n  var chrome = /Chrome\\//.test(navigator.userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var khtml = /KHTML\\//.test(navigator.userAgent);\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn\'t get it to work yet.\n    if (ie_lt9) return false;\n    var div = document.createElement(\'div\');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }();\n\n  // Feature-detect whether newlines in textareas are converted to \\r\\n\n  var lineSep = function () {\n    var te = document.createElement(\"textarea\");\n    te.value = \"foo\\nbar\";\n    if (te.value.indexOf(\"\\r\") > -1) return \"\\r\\n\";\n    return \"\\n\";\n  }();\n\n  // For a reason I have yet to figure out, some browsers disallow\n  // word wrapping between certain characters *only* if a new inline\n  // element is started between them. This makes it hard to reliably\n  // measure the position of things, since that requires inserting an\n  // extra span. This terribly fragile set of regexps matches the\n  // character combinations that suffer from this phenomenon on the\n  // various browsers.\n  var spanAffectsWrapping = /^$/; // Won\'t match any two-character string\n  if (gecko) spanAffectsWrapping = /$\'/;\n  else if (safari) spanAffectsWrapping = /\\-[^ \\-?]|\\?[^ !\'\\\"\\),.\\-\\/:;\\?\\]\\}]/;\n  else if (chrome) spanAffectsWrapping = /\\-[^ \\-\\.?]|\\?[^ \\-\\.?\\]\\}:;!\'\\\"\\),\\/]|[\\.!\\\"#&%\\)*+,:;=>\\]|\\}~][\\(\\{\\[<]|\\$\'/;\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = 0, n = 0; i < end; ++i) {\n      if (string.charAt(i) == \"\\t\") n += tabSize - (n % tabSize);\n      else ++n;\n    }\n    return n;\n  }\n\n  function computedStyle(elt) {\n    if (elt.currentStyle) return elt.currentStyle;\n    return window.getComputedStyle(elt, null);\n  }\n\n  // Find the position of an element by following the offsetParent chain.\n  // If screen==true, it returns screen (rather than page) coordinates.\n  function eltOffset(node, screen) {\n    var bod = node.ownerDocument.body;\n    var x = 0, y = 0, skipBody = false;\n    for (var n = node; n; n = n.offsetParent) {\n      var ol = n.offsetLeft, ot = n.offsetTop;\n      // Firefox reports weird inverted offsets when the body has a border.\n      if (n == bod) { x += Math.abs(ol); y += Math.abs(ot); }\n      else { x += ol, y += ot; }\n      if (screen && computedStyle(n).position == \"fixed\")\n        skipBody = true;\n    }\n    var e = screen && !skipBody ? null : bod;\n    for (var n = node.parentNode; n != e; n = n.parentNode)\n      if (n.scrollLeft != null) { x -= n.scrollLeft; y -= n.scrollTop;}\n    return {left: x, top: y};\n  }\n  // Use the faster and saner getBoundingClientRect method when possible.\n  if (document.documentElement.getBoundingClientRect != null) eltOffset = function(node, screen) {\n    // Take the parts of bounding client rect that we are interested in so we are able to edit if need be,\n    // since the returned value cannot be changed externally (they are kept in sync as the element moves within the page)\n    try { var box = node.getBoundingClientRect(); box = { top: box.top, left: box.left }; }\n    catch(e) { box = {top: 0, left: 0}; }\n    if (!screen) {\n      // Get the toplevel scroll, working around browser differences.\n      if (window.pageYOffset == null) {\n        var t = document.documentElement || document.body.parentNode;\n        if (t.scrollTop == null) t = document.body;\n        box.top += t.scrollTop; box.left += t.scrollLeft;\n      } else {\n        box.top += window.pageYOffset; box.left += window.pageXOffset;\n      }\n    }\n    return box;\n  };\n\n  // Get a node\'s text content.\n  function eltText(node) {\n    return node.textContent || node.innerText || node.nodeValue || \"\";\n  }\n  function selectInput(node) {\n    if (ios) { // Mobile Safari apparently has a bug where select() is broken.\n      node.selectionStart = 0;\n      node.selectionEnd = node.value.length;\n    } else node.select();\n  }\n\n  // Operations on {line, ch} objects.\n  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}\n  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}\n  function copyPos(x) {return {line: x.line, ch: x.ch};}\n\n  var escapeElement = document.createElement(\"pre\");\n  function htmlEscape(str) {\n    escapeElement.textContent = str;\n    return escapeElement.innerHTML;\n  }\n  // Recent (late 2011) Opera betas insert bogus newlines at the start\n  // of the textContent, so we strip those.\n  if (htmlEscape(\"a\") == \"\\na\")\n    htmlEscape = function(str) {\n      escapeElement.textContent = str;\n      return escapeElement.innerHTML.slice(1);\n    };\n  // Some IEs don\'t preserve tabs through innerHTML\n  else if (htmlEscape(\"\\t\") != \"\\t\")\n    htmlEscape = function(str) {\n      escapeElement.innerHTML = \"\";\n      escapeElement.appendChild(document.createTextNode(str));\n      return escapeElement.innerHTML;\n    };\n  CodeMirror.htmlEscape = htmlEscape;\n\n  // Used to position the cursor after an undo/redo by finding the\n  // last edited character.\n  function editEnd(from, to) {\n    if (!to) return 0;\n    if (!from) return to.length;\n    for (var i = from.length, j = to.length; i >= 0 && j >= 0; --i, --j)\n      if (from.charAt(i) != to.charAt(j)) break;\n    return j + 1;\n  }\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n    for (var i = 0, e = collection.length; i < e; ++i)\n      if (collection[i] == elt) return i;\n    return -1;\n  }\n  function isWordChar(ch) {\n    return /\\w/.test(ch) || ch.toUpperCase() != ch.toLowerCase();\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, nl, result = [];\n    while ((nl = string.indexOf(\"\\n\", pos)) > -1) {\n      result.push(string.slice(pos, string.charAt(nl-1) == \"\\r\" ? nl - 1 : nl));\n      pos = nl + 1;\n    }\n    result.push(string.slice(pos));\n    return result;\n  } : function(string){return string.split(/\\r?\\n/);};\n  CodeMirror.splitLines = splitLines;\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  CodeMirror.defineMode(\"null\", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  var keyNames = {3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n                  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n                  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n                  46: \"Delete\", 59: \";\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\", 127: \"Delete\", 186: \";\", 187: \"=\", 188: \",\",\n                  189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\", 221: \"]\", 222: \"\'\", 63276: \"PageUp\",\n                  63277: \"PageDown\", 63275: \"End\", 63273: \"Home\", 63234: \"Left\", 63232: \"Up\", 63235: \"Right\",\n                  63233: \"Down\", 63302: \"Insert\", 63272: \"Delete\"};\n  CodeMirror.keyNames = keyNames;\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n  })();\n\n  return CodeMirror;\n})();'),(605,'mda000000014qocpj4tg1wpei36gtex3','text/css','','.CodeMirror {\n  line-height: 1em;\n  font-family: monospace;\n}\n\n.CodeMirror-scroll {\n  overflow: auto;\n  height: 300px;\n  /* This is needed to prevent an IE[67] bug where the scrolled content\n     is visible outside of the scrolling box. */\n  position: relative;\n  outline: none;\n}\n\n.CodeMirror-gutter {\n  position: absolute; left: 0; top: 0;\n  z-index: 10;\n  background-color: #f7f7f7;\n  border-right: 1px solid #eee;\n  min-width: 2em;\n  height: 100%;\n}\n.CodeMirror-gutter-text {\n  color: #aaa;\n  text-align: right;\n  padding: .4em .2em .4em .4em;\n  white-space: pre !important;\n}\n.CodeMirror-lines {\n  padding: .4em;\n  white-space: pre;\n}\n\n.CodeMirror pre {\n  -moz-border-radius: 0;\n  -webkit-border-radius: 0;\n  -o-border-radius: 0;\n  border-radius: 0;\n  border-width: 0; margin: 0; padding: 0; background: transparent;\n  font-family: inherit;\n  font-size: inherit;\n  padding: 0; margin: 0;\n  white-space: pre;\n  word-wrap: normal;\n  line-height: inherit;\n  color: inherit;\n}\n\n.CodeMirror-wrap pre {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  word-break: normal;\n}\n.CodeMirror-wrap .CodeMirror-scroll {\n  overflow-x: hidden;\n}\n\n.CodeMirror textarea {\n  outline: none !important;\n}\n\n.CodeMirror pre.CodeMirror-cursor {\n  z-index: 10;\n  position: absolute;\n  visibility: hidden;\n  border-left: 1px solid black;\n  border-right: none;\n  width: 0;\n}\n.cm-keymap-fat-cursor pre.CodeMirror-cursor {\n  width: auto;\n  border: 0;\n  background: transparent;\n  background: rgba(0, 200, 0, .4);\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr=#6600c800, endColorstr=#4c00c800);\n}\n/* Kludge to turn off filter in ie9+, which also accepts rgba */\n.cm-keymap-fat-cursor pre.CodeMirror-cursor:not(#nonsense_id) {\n  filter: progid:DXImageTransform.Microsoft.gradient(enabled=false);\n}\n.CodeMirror pre.CodeMirror-cursor.CodeMirror-overwrite {}\n.CodeMirror-focused pre.CodeMirror-cursor {\n  visibility: visible;\n}\n\ndiv.CodeMirror-selected { background: #d9d9d9; }\n.CodeMirror-focused div.CodeMirror-selected { background: #d7d4f0; }\n\n.CodeMirror-searching {\n  background: #ffa;\n  background: rgba(255, 255, 0, .4);\n}\n\n/* Default theme */\n\n.cm-s-default span.cm-keyword {color: #708;}\n.cm-s-default span.cm-atom {color: #219;}\n.cm-s-default span.cm-number {color: #164;}\n.cm-s-default span.cm-def {color: #00f;}\n.cm-s-default span.cm-variable {color: black;}\n.cm-s-default span.cm-variable-2 {color: #05a;}\n.cm-s-default span.cm-variable-3 {color: #085;}\n.cm-s-default span.cm-property {color: black;}\n.cm-s-default span.cm-operator {color: black;}\n.cm-s-default span.cm-comment {color: #a50;}\n.cm-s-default span.cm-string {color: #a11;}\n.cm-s-default span.cm-string-2 {color: #f50;}\n.cm-s-default span.cm-meta {color: #555;}\n.cm-s-default span.cm-error {color: #f00;}\n.cm-s-default span.cm-qualifier {color: #555;}\n.cm-s-default span.cm-builtin {color: #30a;}\n.cm-s-default span.cm-bracket {color: #cc7;}\n.cm-s-default span.cm-tag {color: #170;}\n.cm-s-default span.cm-attribute {color: #00c;}\n.cm-s-default span.cm-header {color: blue;}\n.cm-s-default span.cm-quote {color: #090;}\n.cm-s-default span.cm-hr {color: #999;}\n.cm-s-default span.cm-link {color: #00c;}\n\nspan.cm-header, span.cm-strong {font-weight: bold;}\nspan.cm-em {font-style: italic;}\nspan.cm-emstrong {font-style: italic; font-weight: bold;}\nspan.cm-link {text-decoration: underline;}\n\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0f0;}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #f22;}\n'),(606,'mda000000014qoctcucxomfmjozusrbq','text/css','','.cm-s-elegant span.cm-number, .cm-s-elegant span.cm-string, .cm-s-elegant span.cm-atom {color: #762;}\n.cm-s-elegant span.cm-comment {color: #262; font-style: italic; line-height: 1em;}\n.cm-s-elegant span.cm-meta {color: #555; font-style: italic; line-height: 1em;}\n.cm-s-elegant span.cm-variable {color: black;}\n.cm-s-elegant span.cm-variable-2 {color: #b11;}\n.cm-s-elegant span.cm-qualifier {color: #555;}\n.cm-s-elegant span.cm-keyword {color: #730;}\n.cm-s-elegant span.cm-builtin {color: #30a;}\n.cm-s-elegant span.cm-error {background-color: #fdd;}\n.cm-s-elegant span.cm-link {color: #762;}\n'),(607,'mda000000014qocw4oe9bn9y4noxu6o0','application/x-javascript','','CodeMirror.defineMode(\"htmlmixed\", function(config, parserConfig) {\n  var htmlMode = CodeMirror.getMode(config, {name: \"xml\", htmlMode: true});\n  var jsMode = CodeMirror.getMode(config, \"javascript\");\n  var cssMode = CodeMirror.getMode(config, \"css\");\n\n  function html(stream, state) {\n    var style = htmlMode.token(stream, state.htmlState);\n    if (style == \"tag\" && stream.current() == \">\" && state.htmlState.context) {\n      if (/^script$/i.test(state.htmlState.context.tagName)) {\n        state.token = javascript;\n        state.localState = jsMode.startState(htmlMode.indent(state.htmlState, \"\"));\n        state.mode = \"javascript\";\n      }\n      else if (/^style$/i.test(state.htmlState.context.tagName)) {\n        state.token = css;\n        state.localState = cssMode.startState(htmlMode.indent(state.htmlState, \"\"));\n        state.mode = \"css\";\n      }\n    }\n    return style;\n  }\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current();\n    var close = cur.search(pat);\n    if (close > -1) stream.backUp(cur.length - close);\n    return style;\n  }\n  function javascript(stream, state) {\n    if (stream.match(/^<\\/\\s*script\\s*>/i, false)) {\n      state.token = html;\n      state.localState = null;\n      state.mode = \"html\";\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*script\\s*>/,\n                       jsMode.token(stream, state.localState));\n  }\n  function css(stream, state) {\n    if (stream.match(/^<\\/\\s*style\\s*>/i, false)) {\n      state.token = html;\n      state.localState = null;\n      state.mode = \"html\";\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*style\\s*>/,\n                       cssMode.token(stream, state.localState));\n  }\n\n  return {\n    startState: function() {\n      var state = htmlMode.startState();\n      return {token: html, localState: null, mode: \"html\", htmlState: state};\n    },\n\n    copyState: function(state) {\n      if (state.localState)\n        var local = CodeMirror.copyState(state.token == css ? cssMode : jsMode, state.localState);\n      return {token: state.token, localState: local, mode: state.mode,\n              htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n    },\n\n    token: function(stream, state) {\n      return state.token(stream, state);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.token == html || /^\\s*<\\//.test(textAfter))\n        return htmlMode.indent(state.htmlState, textAfter);\n      else if (state.token == javascript)\n        return jsMode.indent(state.localState, textAfter);\n      else\n        return cssMode.indent(state.localState, textAfter);\n    },\n\n    compareStates: function(a, b) {\n      if (a.mode != b.mode) return false;\n      if (a.localState) return CodeMirror.Pass;\n      return htmlMode.compareStates(a.htmlState, b.htmlState);\n    },\n\n    electricChars: \"/{}:\"\n  }\n}, \"xml\", \"javascript\", \"css\");\n\nCodeMirror.defineMIME(\"text/html\", \"htmlmixed\");\n'),(608,'mda000000014qocwkfofeqtkarene37i','application/x-javascript','','CodeMirror.defineMode(\"xml\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var Kludges = parserConfig.htmlMode ? {\n    autoSelfClosers: {\'area\': true, \'base\': true, \'br\': true, \'col\': true, \'command\': true,\n                      \'embed\': true, \'frame\': true, \'hr\': true, \'img\': true, \'input\': true,\n                      \'keygen\': true, \'link\': true, \'meta\': true, \'param\': true, \'source\': true,\n                      \'track\': true, \'wbr\': true},\n    implicitlyClosed: {\'dd\': true, \'li\': true, \'optgroup\': true, \'option\': true, \'p\': true,\n                       \'rp\': true, \'rt\': true, \'tbody\': true, \'td\': true, \'tfoot\': true,\n                       \'th\': true, \'tr\': true},\n    contextGrabbers: {\n      \'dd\': {\'dd\': true, \'dt\': true},\n      \'dt\': {\'dd\': true, \'dt\': true},\n      \'li\': {\'li\': true},\n      \'option\': {\'option\': true, \'optgroup\': true},\n      \'optgroup\': {\'optgroup\': true},\n      \'p\': {\'address\': true, \'article\': true, \'aside\': true, \'blockquote\': true, \'dir\': true,\n            \'div\': true, \'dl\': true, \'fieldset\': true, \'footer\': true, \'form\': true,\n            \'h1\': true, \'h2\': true, \'h3\': true, \'h4\': true, \'h5\': true, \'h6\': true,\n            \'header\': true, \'hgroup\': true, \'hr\': true, \'menu\': true, \'nav\': true, \'ol\': true,\n            \'p\': true, \'pre\': true, \'section\': true, \'table\': true, \'ul\': true},\n      \'rp\': {\'rp\': true, \'rt\': true},\n      \'rt\': {\'rp\': true, \'rt\': true},\n      \'tbody\': {\'tbody\': true, \'tfoot\': true},\n      \'td\': {\'td\': true, \'th\': true},\n      \'tfoot\': {\'tbody\': true},\n      \'th\': {\'td\': true, \'th\': true},\n      \'thead\': {\'tbody\': true, \'tfoot\': true},\n      \'tr\': {\'tr\': true}\n    },\n    doNotIndent: {\"pre\": true},\n    allowUnquoted: true,\n    allowMissing: false\n  } : {\n    autoSelfClosers: {},\n    implicitlyClosed: {},\n    contextGrabbers: {},\n    doNotIndent: {},\n    allowUnquoted: false,\n    allowMissing: false\n  };\n  var alignCDATA = parserConfig.alignCDATA;\n\n  // Return variables for tokenizers\n  var tagName, type;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        }\n        else if (stream.match(\"--\")) return chain(inBlock(\"comment\", \"-->\"));\n        else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        }\n        else return null;\n      }\n      else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      }\n      else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        stream.eatSpace();\n        tagName = \"\";\n        var c;\n        while ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\\'\\/?]/))) tagName += c;\n        state.tokenize = inTag;\n        return \"tag\";\n      }\n    }\n    else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");          \n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    }\n    else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag\";\n    }\n    else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    }\n    else if (/[\\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      return state.tokenize(stream, state);\n    }\n    else {\n      stream.eatWhile(/[^\\s\\u00a0=<>\\\"\\\'\\/?]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    };\n  }\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  var curState, setStyle;\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) curState.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n\n  function pushContext(tagName, startOfLine) {\n    var noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) || (curState.context && curState.context.noIndent);\n    curState.context = {\n      prev: curState.context,\n      tagName: tagName,\n      indent: curState.indented,\n      startOfLine: startOfLine,\n      noIndent: noIndent\n    };\n  }\n  function popContext() {\n    if (curState.context) curState.context = curState.context.prev;\n  }\n\n  function element(type) {\n    if (type == \"openTag\") {\n      curState.tagName = tagName;\n      return cont(attributes, endtag(curState.startOfLine));\n    } else if (type == \"closeTag\") {\n      var err = false;\n      if (curState.context) {\n        if (curState.context.tagName != tagName) {\n          if (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {\n            popContext();\n          }\n          err = !curState.context || curState.context.tagName != tagName;\n        }\n      } else {\n        err = true;\n      }\n      if (err) setStyle = \"error\";\n      return cont(endclosetag(err));\n    }\n    return cont();\n  }\n  function endtag(startOfLine) {\n    return function(type) {\n      if (type == \"selfcloseTag\" ||\n          (type == \"endTag\" && Kludges.autoSelfClosers.hasOwnProperty(curState.tagName.toLowerCase()))) {\n        maybePopContext(curState.tagName.toLowerCase());\n        return cont();\n      }\n      if (type == \"endTag\") {\n        maybePopContext(curState.tagName.toLowerCase());\n        pushContext(curState.tagName, startOfLine);\n        return cont();\n      }\n      return cont();\n    };\n  }\n  function endclosetag(err) {\n    return function(type) {\n      if (err) setStyle = \"error\";\n      if (type == \"endTag\") { popContext(); return cont(); }\n      setStyle = \"error\";\n      return cont(arguments.callee);\n    }\n  }\n  function maybePopContext(nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!curState.context) {\n        return;\n      }\n      parentTagName = curState.context.tagName.toLowerCase();\n      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext();\n    }\n  }\n\n  function attributes(type) {\n    if (type == \"word\") {setStyle = \"attribute\"; return cont(attribute, attributes);}\n    if (type == \"endTag\" || type == \"selfcloseTag\") return pass();\n    setStyle = \"error\";\n    return cont(attributes);\n  }\n  function attribute(type) {\n    if (type == \"equals\") return cont(attvalue, attributes);\n    if (!Kludges.allowMissing) setStyle = \"error\";\n    return (type == \"endTag\" || type == \"selfcloseTag\") ? pass() : cont();\n  }\n  function attvalue(type) {\n    if (type == \"string\") return cont(attvaluemaybe);\n    if (type == \"word\" && Kludges.allowUnquoted) {setStyle = \"string\"; return cont();}\n    setStyle = \"error\";\n    return (type == \"endTag\" || type == \"selfCloseTag\") ? pass() : cont();\n  }\n  function attvaluemaybe(type) {\n    if (type == \"string\") return cont(attvaluemaybe);\n    else return pass();\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: inText, cc: [], indented: 0, startOfLine: true, tagName: null, context: null};\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        state.startOfLine = true;\n        state.indented = stream.indentation();\n      }\n      if (stream.eatSpace()) return null;\n\n      setStyle = type = tagName = null;\n      var style = state.tokenize(stream, state);\n      state.type = type;\n      if ((style || type) && style != \"comment\") {\n        curState = state;\n        while (true) {\n          var comb = state.cc.pop() || element;\n          if (comb(type || style)) break;\n        }\n      }\n      state.startOfLine = false;\n      return setStyle || style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      if ((state.tokenize != inTag && state.tokenize != inText) ||\n          context && context.noIndent)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      if (alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      if (context && /^<\\//.test(textAfter))\n        context = context.prev;\n      while (context && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return 0;\n    },\n\n    compareStates: function(a, b) {\n      if (a.indented != b.indented || a.tokenize != b.tokenize) return false;\n      for (var ca = a.context, cb = b.context; ; ca = ca.prev, cb = cb.prev) {\n        if (!ca || !cb) return ca == cb;\n        if (ca.tagName != cb.tagName) return false;\n      }\n    },\n\n    electricChars: \"/\"\n  };\n});\n\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nif (!CodeMirror.mimeModes.hasOwnProperty(\"text/html\"))\n  CodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n'),(609,'mda000000014qocwqq8vt5dfqn1l1c9y','application/x-javascript','','CodeMirror.defineMode(\"css\", function(config) {\n  var indentUnit = config.indentUnit, type;\n  function ret(style, tp) {type = tp; return style;}\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == \"@\") {stream.eatWhile(/[\\w\\\\\\-]/); return ret(\"meta\", stream.current());}\n    else if (ch == \"/\" && stream.eat(\"*\")) {\n      state.tokenize = tokenCComment;\n      return tokenCComment(stream, state);\n    }\n    else if (ch == \"<\" && stream.eat(\"!\")) {\n      state.tokenize = tokenSGMLComment;\n      return tokenSGMLComment(stream, state);\n    }\n    else if (ch == \"=\") ret(null, \"compare\");\n    else if ((ch == \"~\" || ch == \"|\") && stream.eat(\"=\")) return ret(null, \"compare\");\n    else if (ch == \"\\\"\" || ch == \"\'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    else if (ch == \"#\") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"atom\", \"hash\");\n    }\n    else if (ch == \"!\") {\n      stream.match(/^\\s*\\w*/);\n      return ret(\"keyword\", \"important\");\n    }\n    else if (/\\d/.test(ch)) {\n      stream.eatWhile(/[\\w.%]/);\n      return ret(\"number\", \"unit\");\n    }\n    else if (/[,.+>*\\/]/.test(ch)) {\n      return ret(null, \"select-op\");\n    }\n    else if (/[;{}:\\[\\]]/.test(ch)) {\n      return ret(null, ch);\n    }\n    else {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret(\"variable\", \"variable\");\n    }\n  }\n\n  function tokenCComment(stream, state) {\n    var maybeEnd = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (maybeEnd && ch == \"/\") {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenSGMLComment(stream, state) {\n    var dashes = 0, ch;\n    while ((ch = stream.next()) != null) {\n      if (dashes >= 2 && ch == \">\") {\n        state.tokenize = tokenBase;\n        break;\n      }\n      dashes = (ch == \"-\") ? dashes + 1 : 0;\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped)\n          break;\n        escaped = !escaped && ch == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  return {\n    startState: function(base) {\n      return {tokenize: tokenBase,\n              baseIndent: base || 0,\n              stack: []};\n    },\n\n    token: function(stream, state) {\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n\n      var context = state.stack[state.stack.length-1];\n      if (type == \"hash\" && context != \"rule\") style = \"string-2\";\n      else if (style == \"variable\") {\n        if (context == \"rule\") style = \"number\";\n        else if (!context || context == \"@media{\") style = \"tag\";\n      }\n\n      if (context == \"rule\" && /^[\\{\\};]$/.test(type))\n        state.stack.pop();\n      if (type == \"{\") {\n        if (context == \"@media\") state.stack[state.stack.length-1] = \"@media{\";\n        else state.stack.push(\"{\");\n      }\n      else if (type == \"}\") state.stack.pop();\n      else if (type == \"@media\") state.stack.push(\"@media\");\n      else if (context == \"{\" && type != \"comment\") state.stack.push(\"rule\");\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      var n = state.stack.length;\n      if (/^\\}/.test(textAfter))\n        n -= state.stack[state.stack.length-1] == \"rule\" ? 2 : 1;\n      return state.baseIndent + n * indentUnit;\n    },\n\n    electricChars: \"}\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/css\", \"css\");\n'),(610,'mda000000014qocwxrjnsnazg5uikde2','application/x-javascript','','CodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var jsonMode = parserConfig.json;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n    return {\n      \"if\": A, \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"delete\": C, \"throw\": C,\n      \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|]/;\n\n  function chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n  }\n\n  function nextUntilUnescaped(stream, end) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (next == end && !escaped)\n        return false;\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return escaped;\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n\n  function jsTokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == \'\"\' || ch == \"\'\")\n      return chain(stream, state, jsTokenString(ch));\n    else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch))\n      return ret(ch);\n    else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    }      \n    else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    }\n    else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        return chain(stream, state, jsTokenComment);\n      }\n      else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      }\n      else if (state.reAllowed) {\n        nextUntilUnescaped(stream, \"/\");\n        stream.eatWhile(/[gimy]/); // \'y\' is \"sticky\" option in Mozilla\n        return ret(\"regexp\", \"string-2\");\n      }\n      else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", null, stream.current());\n      }\n    }\n    else if (ch == \"#\") {\n        stream.skipToEnd();\n        return ret(\"error\", \"error\");\n    }\n    else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n    else {\n      stream.eatWhile(/[\\w\\$_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\n                     ret(\"variable\", \"variable\", word);\n    }\n  }\n\n  function jsTokenString(quote) {\n    return function(stream, state) {\n      if (!nextUntilUnescaped(stream, quote))\n        state.tokenize = jsTokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function jsTokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = jsTokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n  \n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    var state = cx.state;\n    if (state.context) {\n      cx.marked = \"def\";\n      for (var v = state.localVars; v; v = v.next)\n        if (v.name == varname) return;\n      state.localVars = {name: varname, next: state.localVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n  function pushcontext() {\n    if (!cx.state.context) cx.state.localVars = defaultVars;\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state;\n      state.lexical = new JSLexical(state.indented, cx.stream.column(), type, null, state.lexical, info)\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    return function expecting(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(arguments.callee);\n    };\n  }\n\n  function statement(type) {\n    if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n    if (type == \";\") return cont();\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                      poplex, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                         block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                        statement, poplex, popcontext);\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"keyword c\") return cont(maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n    if (type == \"operator\") return cont(expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(expression, \"]\"), poplex, maybeoperator);\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n    \n  function maybeoperator(type, value) {\n    if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n    if (type == \"operator\" || type == \":\") return cont(expression);\n    if (type == \";\") return;\n    if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n    if (type == \".\") return cont(property, maybeoperator);\n    if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperator, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type) {\n    if (type == \"variable\") cx.marked = \"property\";\n    if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == \",\") return cont(what, proceed);\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function commaSeparated(type) {\n      if (type == end) return cont();\n      else return pass(what, proceed);\n    };\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function vardef1(type, value) {\n    if (type == \"variable\"){register(value); return cont(vardef2);}\n    return cont();\n  }\n  function vardef2(type, value) {\n    if (value == \"=\") return cont(expression, vardef2);\n    if (type == \",\") return cont(vardef1);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef1, forspec2);\n    if (type == \";\") return pass(forspec2);\n    if (type == \"variable\") return cont(formaybein);\n    return pass(forspec2);\n  }\n  function formaybein(type, value) {\n    if (value == \"in\") return cont(expression);\n    return cont(maybeoperator, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == \";\") return cont(forspec3);\n    if (value == \"in\") return cont(expression);\n    return cont(expression, expect(\";\"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != \")\") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, statement, popcontext);\n  }\n  function funarg(type, value) {\n    if (type == \"variable\") {register(value); return cont();}\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      return {\n        tokenize: jsTokenBase,\n        reAllowed: true,\n        kwAllowed: true,\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n      }\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n      state.kwAllowed = type != \'.\';\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != jsTokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n      if (type == \"vardef\") return lexical.indented + 4;\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"stat\" || type == \"form\") return lexical.indented + indentUnit;\n      else if (lexical.info == \"switch\" && !closing)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricChars: \":{}\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\n'),(611,'mda000000014qow8qn3ahwzu952lrhfo','text/html','[\"Media\",\"Functions\",\"Interfaces\",\"SiteName\",\"setSession\"]','<title>///</title>\n\n<div>\n\n<div id=\"media\">\n<b>Media</b> <a href=\"http://{{SiteName}}///~/Media/new\" style=\"display:inline; border:0; background:transparent; padding:0; margin:0;\"  >\nnew</a>  <a href=\"http://{{SiteName}}///~/Media/upload\" style=\"display:inline; border:0; background:transparent; padding:0; margin:0;\">\nupload</a><br>\n<ul class=\"category\">\n{{for Media as movabl_id:movabl}}\n\n<li class=\"media\"><a href=\"http://{{SiteName}}///~/Media/{{movabl_id}}\" >\n  {{movabl[\"label\"]}} /// {{movabl_id}}</a></li>\n{{endfor}}\n</ul>\n</div>\n\n\n<div id=\"function\">\n<b>Functions</b> <a href=\"http://{{SiteName}}///~/Function/new\" >\nnew</a><br>\n<ul class=\"category\">\n{{for Functions as movabl_id:movabl}}\n<li class=\"function\"><a href=\"http://{{SiteName}}///~/Function/{{movabl_id}}\" >\n  {{movabl[\"label\"]}} /// {{movabl_id}}</a></li>\n{{endfor}}\n</ul>\n</div>\n\n<div id=\"interface\">\n<b>Interfaces</b><a href=\"http://{{SiteName}}///~/Interface/new\" >\nnew</a><br>\n<ul class=\"category\">\n{{for Interfaces as movabl_id:movabl}}\n\n<li class=\"interface\"><a href=\"http://{{SiteName}}///~/Interface/{{movabl_id}}\"  >\n  {{movabl[\"meta\"][\"label\"]}} /// {{movabl_id}}</a></li>\n{{endfor}}\n</ul>\n</div>\n\n\n</div>'),(615,'mda000000014qpe9te1cyto3lt7mxva6','application/javascript','',' (function() {\n  function keywords(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n  function heredoc(delim) {\n    return function(stream, state) {\n      if (stream.match(delim)) state.tokenize = null;\n      else stream.skipToEnd();\n      return \"string\";\n    }\n  }\n  var phpConfig = {\n    name: \"clike\",\n    keywords: keywords(\"abstract and array as break case catch class clone const continue declare default \" +\n                       \"do else elseif enddeclare endfor endforeach endif endswitch endwhile extends final \" +\n                       \"for foreach function global goto if implements interface instanceof namespace \" +\n                       \"new or private protected public static switch throw trait try use var while xor \" +\n                       \"die echo empty exit eval include include_once isset list require require_once return \" +\n                       \"print unset __halt_compiler self static parent\"),\n    blockKeywords: keywords(\"catch do else elseif for foreach if switch try while\"),\n    atoms: keywords(\"true false null TRUE FALSE NULL\"),\n    multiLineStrings: true,\n    hooks: {\n      \"$\": function(stream, state) {\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"variable-2\";\n      },\n      \"<\": function(stream, state) {\n        if (stream.match(/<</)) {\n          stream.eatWhile(/[\\w\\.]/);\n          state.tokenize = heredoc(stream.current().slice(3));\n          return state.tokenize(stream, state);\n        }\n        return false;\n      },\n      \"#\": function(stream, state) {\n        while (!stream.eol() && !stream.match(\"?>\", false)) stream.next();\n        return \"comment\";\n      },\n      \"/\": function(stream, state) {\n        if (stream.eat(\"/\")) {\n          while (!stream.eol() && !stream.match(\"?>\", false)) stream.next();\n          return \"comment\";\n        }\n        return false;\n      }\n    }\n  };\n\n  CodeMirror.defineMode(\"php\", function(config, parserConfig) {\n    var htmlMode = CodeMirror.getMode(config, {name: \"xml\", htmlMode: true});\n    var jsMode = CodeMirror.getMode(config, \"javascript\");\n    var cssMode = CodeMirror.getMode(config, \"css\");\n    var phpMode = CodeMirror.getMode(config, phpConfig);\n\n    function dispatch(stream, state) { // TODO open PHP inside text/css\n      var isPHP = state.mode == \"php\";\n      if (stream.sol() && state.pending != \'\"\') state.pending = null;\n      if (state.curMode == htmlMode) {\n        if (stream.match(/^<\\?\\w*/)) {\n          state.curMode = phpMode;\n          state.curState = state.php;\n          state.curClose = \"?>\";\n	  state.mode = \"php\";\n          return \"meta\";\n        }\n        if (state.pending == \'\"\') {\n          while (!stream.eol() && stream.next() != \'\"\') {}\n          var style = \"string\";\n        } else if (state.pending && stream.pos < state.pending.end) {\n          stream.pos = state.pending.end;\n          var style = state.pending.style;\n        } else {\n          var style = htmlMode.token(stream, state.curState);\n        }\n        state.pending = null;\n        var cur = stream.current(), openPHP = cur.search(/<\\?/);\n        if (openPHP != -1) {\n          if (style == \"string\" && /\\\"$/.test(cur) && !/\\?>/.test(cur)) state.pending = \'\"\';\n          else state.pending = {end: stream.pos, style: style};\n          stream.backUp(cur.length - openPHP);\n        } else if (style == \"tag\" && stream.current() == \">\" && state.curState.context) {\n          if (/^script$/i.test(state.curState.context.tagName)) {\n            state.curMode = jsMode;\n            state.curState = jsMode.startState(htmlMode.indent(state.curState, \"\"));\n            state.curClose = /^<\\/\\s*script\\s*>/i;\n	    state.mode = \"javascript\";\n          }\n          else if (/^style$/i.test(state.curState.context.tagName)) {\n            state.curMode = cssMode;\n            state.curState = cssMode.startState(htmlMode.indent(state.curState, \"\"));\n            state.curClose = /^<\\/\\s*style\\s*>/i;\n            state.mode = \"css\";\n          }\n        }\n        return style;\n      } else if ((!isPHP || state.php.tokenize == null) &&\n                 stream.match(state.curClose, isPHP)) {\n        state.curMode = htmlMode;\n        state.curState = state.html;\n        state.curClose = null;\n	state.mode = \"html\";\n        if (isPHP) return \"meta\";\n        else return dispatch(stream, state);\n      } else {\n        return state.curMode.token(stream, state.curState);\n      }\n    }\n\n    return {\n      startState: function() {\n        var html = htmlMode.startState();\n        return {html: html,\n                php: phpMode.startState(),\n                curMode: parserConfig.startOpen ? phpMode : htmlMode,\n                curState: parserConfig.startOpen ? phpMode.startState() : html,\n                curClose: parserConfig.startOpen ? /^\\?>/ : null,\n		mode: parserConfig.startOpen ? \"php\" : \"html\",\n                pending: null}\n      },\n\n      copyState: function(state) {\n        var html = state.html, htmlNew = CodeMirror.copyState(htmlMode, html),\n            php = state.php, phpNew = CodeMirror.copyState(phpMode, php), cur;\n        if (state.curState == html) cur = htmlNew;\n        else if (state.curState == php) cur = phpNew;\n        else cur = CodeMirror.copyState(state.curMode, state.curState);\n        return {html: htmlNew, php: phpNew, curMode: state.curMode, curState: cur,\n                curClose: state.curClose, mode: state.mode,\n                pending: state.pending};\n      },\n\n      token: dispatch,\n\n      indent: function(state, textAfter) {\n        if ((state.curMode != phpMode && /^\\s*<\\//.test(textAfter)) ||\n            (state.curMode == phpMode && /^\\?>/.test(textAfter)))\n          return htmlMode.indent(state.html, textAfter);\n        return state.curMode.indent(state.curState, textAfter);\n      },\n\n      electricChars: \"/{}:\"\n    }\n  }, \"xml\", \"clike\", \"javascript\", \"css\");\n  CodeMirror.defineMIME(\"application/x-httpd-php\", \"php\");\n  CodeMirror.defineMIME(\"application/x-httpd-php-open\", {name: \"php\", startOpen: true});\n  CodeMirror.defineMIME(\"text/x-php\", phpConfig);\n})();'),(616,'mda000000014qpe9vqy0qq5bpmcbtcdg','application/javascript','',' CodeMirror.defineMode(\"clike\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit,\n      keywords = parserConfig.keywords || {},\n      blockKeywords = parserConfig.blockKeywords || {},\n      atoms = parserConfig.atoms || {},\n      hooks = parserConfig.hooks || {},\n      multiLineStrings = parserConfig.multiLineStrings;\n  var isOperatorChar = /[+\\-*&%=<>!?|\\/]/;\n\n  var curPunc;\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (hooks[ch]) {\n      var result = hooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n    if (ch == \'\"\' || ch == \"\'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n    if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      curPunc = ch;\n      return null;\n    }\n    if (/\\d/.test(ch)) {\n      stream.eatWhile(/[\\w\\.]/);\n      return \"number\";\n    }\n    if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n    }\n    if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return \"operator\";\n    }\n    stream.eatWhile(/[\\w\\$_]/);\n    var cur = stream.current();\n    if (keywords.propertyIsEnumerable(cur)) {\n      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n      return \"keyword\";\n    }\n    if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n    return \"word\";\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {end = true; break;}\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !(escaped || multiLineStrings))\n        state.tokenize = null;\n      return \"string\";\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = null;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function Context(indented, column, type, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.align = align;\n    this.prev = prev;\n  }\n  function pushContext(state, col, type) {\n    return state.context = new Context(state.indented, col, type, null, state.context);\n  }\n  function popContext(state) {\n    var t = state.context.type;\n    if (t == \")\" || t == \"]\" || t == \"}\")\n      state.indented = state.context.indented;\n    return state.context = state.context.prev;\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      return {\n        tokenize: null,\n        context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", false),\n        indented: 0,\n        startOfLine: true\n      };\n    },\n\n    token: function(stream, state) {\n      var ctx = state.context;\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n      }\n      if (stream.eatSpace()) return null;\n      curPunc = null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style == \"comment\" || style == \"meta\") return style;\n      if (ctx.align == null) ctx.align = true;\n\n      if ((curPunc == \";\" || curPunc == \":\") && ctx.type == \"statement\") popContext(state);\n      else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");\n      else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");\n      else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");\n      else if (curPunc == \"}\") {\n        while (ctx.type == \"statement\") ctx = popContext(state);\n        if (ctx.type == \"}\") ctx = popContext(state);\n        while (ctx.type == \"statement\") ctx = popContext(state);\n      }\n      else if (curPunc == ctx.type) popContext(state);\n      else if (ctx.type == \"}\" || ctx.type == \"top\" || (ctx.type == \"statement\" && curPunc == \"newstatement\"))\n        pushContext(state, stream.column(), \"statement\");\n      state.startOfLine = false;\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != tokenBase && state.tokenize != null) return 0;\n      var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n      if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n      var closing = firstChar == ctx.type;\n      if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : indentUnit);\n      else if (ctx.align) return ctx.column + (closing ? 0 : 1);\n      else return ctx.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricChars: \"{}\"\n  };\n});\n\n(function() {\n  function words(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n  var cKeywords = \"auto if break int case long char register continue return default short do sizeof \" +\n    \"double static else struct entry switch extern typedef float union for unsigned \" +\n    \"goto while enum void const signed volatile\";\n\n  function cppHook(stream, state) {\n    if (!state.startOfLine) return false;\n    stream.skipToEnd();\n    return \"meta\";\n  }\n\n  // C#-style strings where \"\" escapes a quote.\n  function tokenAtString(stream, state) {\n    var next;\n    while ((next = stream.next()) != null) {\n      if (next == \'\"\' && !stream.eat(\'\"\')) {\n        state.tokenize = null;\n        break;\n      }\n    }\n    return \"string\";\n  }\n\n  CodeMirror.defineMIME(\"text/x-csrc\", {\n    name: \"clike\",\n    keywords: words(cKeywords),\n    blockKeywords: words(\"case do else for if switch while struct\"),\n    atoms: words(\"null\"),\n    hooks: {\"#\": cppHook}\n  });\n  CodeMirror.defineMIME(\"text/x-c++src\", {\n    name: \"clike\",\n    keywords: words(cKeywords + \" asm dynamic_cast namespace reinterpret_cast try bool explicit new \" +\n                    \"static_cast typeid catch operator template typename class friend private \" +\n                    \"this using const_cast inline public throw virtual delete mutable protected \" +\n                    \"wchar_t\"),\n    blockKeywords: words(\"catch class do else finally for if struct switch try while\"),\n    atoms: words(\"true false null\"),\n    hooks: {\"#\": cppHook}\n  });\n  CodeMirror.defineMIME(\"text/x-java\", {\n    name: \"clike\",\n    keywords: words(\"abstract assert boolean break byte case catch char class const continue default \" + \n                    \"do double else enum extends final finally float for goto if implements import \" +\n                    \"instanceof int interface long native new package private protected public \" +\n                    \"return short static strictfp super switch synchronized this throw throws transient \" +\n                    \"try void volatile while\"),\n    blockKeywords: words(\"catch class do else finally for if switch try while\"),\n    atoms: words(\"true false null\"),\n    hooks: {\n      \"@\": function(stream, state) {\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      }\n    }\n  });\n  CodeMirror.defineMIME(\"text/x-csharp\", {\n    name: \"clike\",\n    keywords: words(\"abstract as base bool break byte case catch char checked class const continue decimal\" + \n                    \" default delegate do double else enum event explicit extern finally fixed float for\" + \n                    \" foreach goto if implicit in int interface internal is lock long namespace new object\" + \n                    \" operator out override params private protected public readonly ref return sbyte sealed short\" + \n                    \" sizeof stackalloc static string struct switch this throw try typeof uint ulong unchecked\" + \n                    \" unsafe ushort using virtual void volatile while add alias ascending descending dynamic from get\" + \n                    \" global group into join let orderby partial remove select set value var yield\"),\n    blockKeywords: words(\"catch class do else finally for foreach if struct switch try while\"),\n    atoms: words(\"true false null\"),\n    hooks: {\n      \"@\": function(stream, state) {\n        if (stream.eat(\'\"\')) {\n          state.tokenize = tokenAtString;\n          return tokenAtString(stream, state);\n        }\n        stream.eatWhile(/[\\w\\$_]/);\n        return \"meta\";\n      }\n    }\n  });\n}());'),(618,'mda000000014qphjzial4zx0k19295nd','application/javascript','','// Define search commands. Depends on dialog.js or another\n// implementation of the openDialog method.\n\n// Replace works a little oddly -- it will do the replace on the next\n// Ctrl-G (or whatever is bound to findNext) press. You prevent a\n// replace by making sure the match is no longer selected when hitting\n// Ctrl-G.\n\n(function() {\n  function SearchState() {\n    this.posFrom = this.posTo = this.query = null;\n    this.marked = [];\n  }\n  function getSearchState(cm) {\n    return cm._searchState || (cm._searchState = new SearchState());\n  }\n  function dialog(cm, text, shortText, f) {\n    if (cm.openDialog) cm.openDialog(text, f);\n    else f(prompt(shortText, \"\"));\n  }\n  function confirmDialog(cm, text, shortText, fs) {\n    if (cm.openConfirm) cm.openConfirm(text, fs);\n    else if (confirm(shortText)) fs[0]();\n  }\n  function parseQuery(query) {\n    var isRE = query.match(/^\\/(.*)\\/$/);\n    return isRE ? new RegExp(isRE[1]) : query;\n  }\n  var queryDialog =\n    \'Search: <input type=\"text\" style=\"width: 10em\"/> <span style=\"color: #888\">(Use /re/ syntax for regexp search)</span>\';\n  function doSearch(cm, rev) {\n    var state = getSearchState(cm);\n    if (state.query) return findNext(cm, rev);\n    dialog(cm, queryDialog, \"Search for:\", function(query) {\n      cm.operation(function() {\n        if (!query || state.query) return;\n        state.query = parseQuery(query);\n        if (cm.lineCount() < 2000) { // This is too expensive on big documents.\n          for (var cursor = cm.getSearchCursor(query); cursor.findNext();)\n            state.marked.push(cm.markText(cursor.from(), cursor.to(), \"CodeMirror-searching\"));\n        }\n        state.posFrom = state.posTo = cm.getCursor();\n        findNext(cm, rev);\n      });\n    });\n  }\n  function findNext(cm, rev) {cm.operation(function() {\n    var state = getSearchState(cm);\n    var cursor = cm.getSearchCursor(state.query, rev ? state.posFrom : state.posTo);\n    if (!cursor.find(rev)) {\n      cursor = cm.getSearchCursor(state.query, rev ? {line: cm.lineCount() - 1} : {line: 0, ch: 0});\n      if (!cursor.find(rev)) return;\n    }\n    cm.setSelection(cursor.from(), cursor.to());\n    state.posFrom = cursor.from(); state.posTo = cursor.to();\n  })}\n  function clearSearch(cm) {cm.operation(function() {\n    var state = getSearchState(cm);\n    if (!state.query) return;\n    state.query = null;\n    for (var i = 0; i < state.marked.length; ++i) state.marked[i].clear();\n    state.marked.length = 0;\n  })}\n\n  var replaceQueryDialog =\n    \'Replace: <input type=\"text\" style=\"width: 10em\"/> <span style=\"color: #888\">(Use /re/ syntax for regexp search)</span>\';\n  var replacementQueryDialog = \'With: <input type=\"text\" style=\"width: 10em\"/>\';\n  var doReplaceConfirm = \"Replace? <button>Yes</button> <button>No</button> <button>Stop</button>\";\n  function replace(cm, all) {\n    dialog(cm, replaceQueryDialog, \"Replace:\", function(query) {\n      if (!query) return;\n      query = parseQuery(query);\n      dialog(cm, replacementQueryDialog, \"Replace with:\", function(text) {\n        if (all) {\n          cm.compoundChange(function() { cm.operation(function() {\n            for (var cursor = cm.getSearchCursor(query); cursor.findNext();) {\n              if (typeof query != \"string\") {\n                var match = cm.getRange(cursor.from(), cursor.to()).match(query);\n                cursor.replace(text.replace(/\\$(\\d)/, function(w, i) {return match[i];}));\n              } else cursor.replace(text);\n            }\n          })});\n        } else {\n          clearSearch(cm);\n          var cursor = cm.getSearchCursor(query, cm.getCursor());\n          function advance() {\n            var start = cursor.from(), match;\n            if (!(match = cursor.findNext())) {\n              cursor = cm.getSearchCursor(query);\n              if (!(match = cursor.findNext()) ||\n                  (cursor.from().line == start.line && cursor.from().ch == start.ch)) return;\n            }\n            cm.setSelection(cursor.from(), cursor.to());\n            confirmDialog(cm, doReplaceConfirm, \"Replace?\",\n                          [function() {doReplace(match);}, advance]);\n          }\n          function doReplace(match) {\n            cursor.replace(typeof query == \"string\" ? text :\n                           text.replace(/\\$(\\d)/, function(w, i) {return match[i];}));\n            advance();\n          }\n          advance();\n        }\n      });\n    });\n  }\n\n  CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};\n  CodeMirror.commands.findNext = doSearch;\n  CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};\n  CodeMirror.commands.clearSearch = clearSearch;\n  CodeMirror.commands.replace = replace;\n  CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};\n})();'),(619,'mda000000014qphk3qgaj54tzqarmbd2','application/javascript','','// Open simple dialogs on top of an editor. Relies on dialog.css.\n\n(function() {\n  function dialogDiv(cm, template) {\n    var wrap = cm.getWrapperElement();\n    var dialog = wrap.insertBefore(document.createElement(\"div\"), wrap.firstChild);\n    dialog.className = \"CodeMirror-dialog\";\n    dialog.innerHTML = \'<div>\' + template + \'</div>\';\n    return dialog;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback) {\n    var dialog = dialogDiv(this, template);\n    var closed = false, me = this;\n    function close() {\n      if (closed) return;\n      closed = true;\n      dialog.parentNode.removeChild(dialog);\n    }\n    var inp = dialog.getElementsByTagName(\"input\")[0];\n    if (inp) {\n      CodeMirror.connect(inp, \"keydown\", function(e) {\n        if (e.keyCode == 13 || e.keyCode == 27) {\n          CodeMirror.e_stop(e);\n          close();\n          me.focus();\n          if (e.keyCode == 13) callback(inp.value);\n        }\n      });\n      inp.focus();\n      CodeMirror.connect(inp, \"blur\", close);\n    }\n    return close;\n  });\n\n  CodeMirror.defineExtension(\"openConfirm\", function(template, callbacks) {\n    var dialog = dialogDiv(this, template);\n    var buttons = dialog.getElementsByTagName(\"button\");\n    var closed = false, me = this, blurring = 1;\n    function close() {\n      if (closed) return;\n      closed = true;\n      dialog.parentNode.removeChild(dialog);\n      me.focus();\n    }\n    buttons[0].focus();\n    for (var i = 0; i < buttons.length; ++i) {\n      var b = buttons[i];\n      (function(callback) {\n        CodeMirror.connect(b, \"click\", function(e) {\n          CodeMirror.e_preventDefault(e);\n          close();\n          if (callback) callback(me);\n        });\n      })(callbacks[i]);\n      CodeMirror.connect(b, \"blur\", function() {\n        --blurring;\n        setTimeout(function() { if (blurring <= 0) close(); }, 200);\n      });\n      CodeMirror.connect(b, \"focus\", function() { ++blurring; });\n    }\n  });\n})();'),(620,'mda000000014qphk88zd3kgyohkpob3a','text/css','','.CodeMirror-dialog {\n  position: relative;\n}\n\n.CodeMirror-dialog > div {\n  position: absolute;\n  top: 0; left: 0; right: 0;\n  background: white;\n  border-bottom: 1px solid #eee;\n  z-index: 15;\n  padding: .1em .8em;\n  overflow: hidden;\n  color: #333;\n}\n\n.CodeMirror-dialog input {\n  border: none;\n  outline: none;\n  background: transparent;\n  width: 20em;\n  color: inherit;\n  font-family: monospace;\n}'),(621,'mda000000014qphl8gy9lbpdqpogvqe6','application/javascript','','(function(){\n  function SearchCursor(cm, query, pos, caseFold) {\n    this.atOccurrence = false; this.cm = cm;\n    if (caseFold == null && typeof query == \"string\") caseFold = false;\n\n    pos = pos ? cm.clipPos(pos) : {line: 0, ch: 0};\n    this.pos = {from: pos, to: pos};\n\n    // The matches method is filled in based on the type of query.\n    // It takes a position and a direction, and returns an object\n    // describing the next occurrence of the query, or null if no\n    // more matches were found.\n    if (typeof query != \"string\") // Regexp match\n      this.matches = function(reverse, pos) {\n        if (reverse) {\n          var line = cm.getLine(pos.line).slice(0, pos.ch), match = line.match(query), start = 0;\n          while (match) {\n            var ind = line.indexOf(match[0]);\n            start += ind;\n            line = line.slice(ind + 1);\n            var newmatch = line.match(query);\n            if (newmatch) match = newmatch;\n            else break;\n            start++;\n          }\n        }\n        else {\n          var line = cm.getLine(pos.line).slice(pos.ch), match = line.match(query),\n          start = match && pos.ch + line.indexOf(match[0]);\n        }\n        if (match)\n          return {from: {line: pos.line, ch: start},\n                  to: {line: pos.line, ch: start + match[0].length},\n                  match: match};\n      };\n    else { // String query\n      if (caseFold) query = query.toLowerCase();\n      var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};\n      var target = query.split(\"\\n\");\n      // Different methods for single-line and multi-line queries\n      if (target.length == 1)\n        this.matches = function(reverse, pos) {\n          var line = fold(cm.getLine(pos.line)), len = query.length, match;\n          if (reverse ? (pos.ch >= len && (match = line.lastIndexOf(query, pos.ch - len)) != -1)\n              : (match = line.indexOf(query, pos.ch)) != -1)\n            return {from: {line: pos.line, ch: match},\n                    to: {line: pos.line, ch: match + len}};\n        };\n      else\n        this.matches = function(reverse, pos) {\n          var ln = pos.line, idx = (reverse ? target.length - 1 : 0), match = target[idx], line = fold(cm.getLine(ln));\n          var offsetA = (reverse ? line.indexOf(match) + match.length : line.lastIndexOf(match));\n          if (reverse ? offsetA >= pos.ch || offsetA != match.length\n              : offsetA <= pos.ch || offsetA != line.length - match.length)\n            return;\n          for (;;) {\n            if (reverse ? !ln : ln == cm.lineCount() - 1) return;\n            line = fold(cm.getLine(ln += reverse ? -1 : 1));\n            match = target[reverse ? --idx : ++idx];\n            if (idx > 0 && idx < target.length - 1) {\n              if (line != match) return;\n              else continue;\n            }\n            var offsetB = (reverse ? line.lastIndexOf(match) : line.indexOf(match) + match.length);\n            if (reverse ? offsetB != line.length - match.length : offsetB != match.length)\n              return;\n            var start = {line: pos.line, ch: offsetA}, end = {line: ln, ch: offsetB};\n            return {from: reverse ? end : start, to: reverse ? start : end};\n          }\n        };\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false);},\n    findPrevious: function() {return this.find(true);},\n\n    find: function(reverse) {\n      var self = this, pos = this.cm.clipPos(reverse ? this.pos.from : this.pos.to);\n      function savePosAndFail(line) {\n        var pos = {line: line, ch: 0};\n        self.pos = {from: pos, to: pos};\n        self.atOccurrence = false;\n        return false;\n      }\n\n      for (;;) {\n        if (this.pos = this.matches(reverse, pos)) {\n          this.atOccurrence = true;\n          return this.pos.match || true;\n        }\n        if (reverse) {\n          if (!pos.line) return savePosAndFail(0);\n          pos = {line: pos.line-1, ch: this.cm.getLine(pos.line-1).length};\n        }\n        else {\n          var maxLine = this.cm.lineCount();\n          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);\n          pos = {line: pos.line+1, ch: 0};\n        }\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from;},\n    to: function() {if (this.atOccurrence) return this.pos.to;},\n\n    replace: function(newText) {\n      var self = this;\n      if (this.atOccurrence)\n        self.pos.to = this.cm.replaceRange(newText, self.pos.from, self.pos.to);\n    }\n  };\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold);\n  });\n})();');
/*!40000 ALTER TABLE `mvs_media` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mvs_meta`
--

DROP TABLE IF EXISTS `mvs_meta`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mvs_meta` (
  `meta_id` int(11) NOT NULL AUTO_INCREMENT,
  `movabls_GUID` varchar(32) CHARACTER SET utf8 NOT NULL,
  `movabls_type` enum('package','place','interface','function','media','function_tag','media_tag','interface_tag','group') CHARACTER SET utf8 NOT NULL,
  `tag_name` varchar(128) CHARACTER SET utf8 DEFAULT NULL,
  `key` varchar(128) CHARACTER SET utf8 NOT NULL,
  `value` longtext CHARACTER SET utf8 NOT NULL,
  `k` int(11) NOT NULL,
  PRIMARY KEY (`meta_id`),
  UNIQUE KEY `unique` (`movabls_GUID`,`movabls_type`,`tag_name`,`key`)
) ENGINE=InnoDB AUTO_INCREMENT=1132 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mvs_meta`
--

LOCK TABLES `mvs_meta` WRITE;
/*!40000 ALTER TABLE `mvs_meta` DISABLE KEYS */;
INSERT INTO `mvs_meta` VALUES (38,'place','media',NULL,'label','Place Details!',1),(42,'function','media',NULL,'label','Function Details',1),(53,'basejs','media',NULL,'label','Base JS',1),(66,'place','interface',NULL,'label','place',1),(68,'interface','interface',NULL,'label','interface',1),(69,'function','interface',NULL,'label','function',1),(70,'media','interface',NULL,'label','media',1),(88,'root','place',NULL,'label','Your Home Page',1),(89,'root','place',NULL,'parent','root',1),(90,'function','place',NULL,'label','function editor',1),(91,'function','place',NULL,'parent','movabls',1),(92,'interface','place',NULL,'label','interface editor',1),(93,'interface','place',NULL,'parent','movabls',1),(97,'Set_Media','place',NULL,'parent','media',1),(98,'Set_Interface','place',NULL,'parent','interface',1),(99,'Set_Function','place',NULL,'parent','function',1),(100,'place','place',NULL,'parent','movabls',1),(101,'place','place',NULL,'label','place editor',1),(105,'basejs','place',NULL,'parent','movabls',1),(161,'media_mime','function',NULL,'label','media_mime',1),(162,'encode_inputs','function',NULL,'label','encode_inputs',1),(163,'post_media','function',NULL,'label','post media',1),(165,'mapinterface','function',NULL,'label','pretty json',1),(166,'post_interface','function',NULL,'label','post_interface',1),(167,'post_function','function','','label','post function',1),(168,'post_place','function',NULL,'label','post place',1),(213,'TEST_MEDIA','media',NULL,'label','Light Co.',1),(214,'Set_Media','media',NULL,'label','Set_Media',1),(219,'Set_Function','media',NULL,'label','Set_Function',1),(220,'Set_Interface','media',NULL,'label','Set_Interface',1),(230,'Set_Media','interface',NULL,'label','Set_Media',1),(231,'Set_Interface','interface',NULL,'label','Set_Interface',1),(232,'Set_Function','interface',NULL,'label','Set_Function',1),(240,'home','package',NULL,'label','Your Home Page',1),(241,'movabls_ide','package',NULL,'label','Movabls',1),(247,'basejs','place',NULL,'label','Base.JS',1),(340,'mda000000014h5a7m1l8osd0tsw41flr','media',NULL,'label','Interface Details',1),(350,'Set_Media','place',NULL,'label','Set_Media',1),(351,'Set_Function','place',NULL,'label','Set_Function',1),(352,'Set_Interface','place',NULL,'label','Set_Interface',1),(687,'int00000001glh2dr7pnbpcy78qg6rl','interface',NULL,'label','Create User',1),(688,'mda000000014lyqp22tpp8k25mh8wgi7','media',NULL,'label','Create User',1),(689,'plc000000014lyqp22z9nrf84hu6rotp','place',NULL,'label','Create User',1),(690,'plc000000014lyqp22z9nrf84hu6rotp','place',NULL,'parent','root',1),(691,'fnc000000014lyqqh8khw7l30vclu860','function',NULL,'label','create user',1),(692,'int000000014lyqqzrupsywpmwe8qbv4','interface',NULL,'label','Sign In',1),(693,'fnc000000014lyqr1polu0a35j52dkp8','function',NULL,'label','Sign In',1),(694,'mda000000014lyqras857620egeb2nof','media',NULL,'label','Sign In',1),(695,'plc000000014lyqrasaxc1zgu1boq4u8','place',NULL,'label','Sign In',1),(696,'plc000000014lyqrasaxc1zgu1boq4u8','place',NULL,'parent','root',1),(703,'fnc000000014m06jtvjxs6oazcz8sc0i','function',NULL,'label','Get Packages',1),(704,'fnc000000014m06juwo1wadqxwwlwvh3','function',NULL,'label','Get Users',1),(705,'fnc000000014m06k0b6t0b01tykdgrhg','function',NULL,'label','Get Groups',1),(706,'int000000014m06k27mpbe52oinx50wp','interface',NULL,'label','Places',1),(707,'int000000014m06k2yy168hl0rowyh7b','interface',NULL,'label','Users',1),(709,'int00000001glm97mulr65ec3esadx7','interface',NULL,'label','Packages',1),(710,'mda000000014m06kahjp4o5a325mllkx','media',NULL,'label','Places',1),(711,'plc000000014m06kahp9xarxrkdmevjg','place',NULL,'label','Places',1),(712,'plc000000014m06kahp9xarxrkdmevjg','place',NULL,'parent','root',1),(713,'mda000000014m06kdv5hohtdbnmy1ha4','media',NULL,'label','Users',1),(714,'plc000000014m06kdvb1hphffwsdt4gl','place',NULL,'label','Users',1),(715,'plc000000014m06kdvb1hphffwsdt4gl','place',NULL,'parent','root',1),(716,'mda000000014m06kgzylc1gi49c513lx','media',NULL,'label','Packages',1),(717,'plc000000014m06kh0457fuxvhwejse8','place',NULL,'label','Packages',1),(718,'plc000000014m06kh0457fuxvhwejse8','place',NULL,'parent','root',1),(726,'int000000014m1gnlhchxxo0xfz4hb06','interface',NULL,'label','create group',1),(727,'fnc000000014m1gofu0lae0xbfhfo799','function',NULL,'label','Create Group',1),(728,'mda000000014m1gq71v5rm45y8czvbt5','media',NULL,'label','create group',1),(729,'plc000000014m1gq71xx79qmjx1r6thq','place',NULL,'label','create group',1),(730,'plc000000014m1gq71xx79qmjx1r6thq','place',NULL,'parent','root',1),(731,'int000000014m1hsqj0lqf7uh3mqszmf','interface',NULL,'label','Create Package',1),(732,'fnc00000001glqzaqhhpzqshz7n7wxq','function',NULL,'label','Create Package',1),(733,'mda000000011nrwbxht6m4772q81ali','media',NULL,'label','Create Package',1),(734,'plc000000014m1ht50jlt88at7gzltpn','place',NULL,'label','Create Package',1),(735,'plc000000014m1ht50jlt88at7gzltpn','place',NULL,'parent','root',1),(1073,'mda000000014qocmi1dw4lpwq5lzmnbq','media',NULL,'label','Media Details',1),(1074,'plc000000014qocmi38hpew34ro4ppuz','place',NULL,'label','code mirror',1),(1075,'plc000000014qocmi38hpew34ro4ppuz','place',NULL,'parent','root',1),(1076,'pkg000000014qocp8n1jyedpzud01io7','package',NULL,'label','codemirror',1),(1077,'mda000000014qocp8oapfg3gx2z9z6xj','media',NULL,'label','codemirror .js',1),(1078,'plc000000014qocp8pr75epkjtdvjjkq','place',NULL,'label','codemirror .js',1),(1079,'plc000000014qocp8pr75epkjtdvjjkq','place',NULL,'parent','root',1),(1080,'mda000000014qocpj4tg1wpei36gtex3','media',NULL,'label','codemirror css',1),(1081,'plc000000014qocpj66mxnnltcayx0eu','place',NULL,'label','codemirror css',1),(1082,'plc000000014qocpj66mxnnltcayx0eu','place',NULL,'parent','root',1),(1083,'mda000000014qoctcucxomfmjozusrbq','media',NULL,'label','codemirror elegant css',1),(1084,'plc000000014qoctcvy9dvsyik9lk2a0','place',NULL,'label','codemirror elegant css',1),(1085,'plc000000014qoctcvy9dvsyik9lk2a0','place',NULL,'parent','root',1),(1086,'mda000000014qocw4oe9bn9y4noxu6o0','media',NULL,'label','code mirror mode htmlmixed.js',1),(1087,'plc000000014qocw4q04j5adbrp4xoya','place',NULL,'label','code mirror mode htmlmixed.js',1),(1088,'plc000000014qocw4q04j5adbrp4xoya','place',NULL,'parent','root',1),(1089,'mda000000014qocwkfofeqtkarene37i','media',NULL,'label','codemirror mode xml',1),(1090,'plc000000014qocwkh25d7xqgux3j3oh','place',NULL,'label','codemirror mode xml',1),(1091,'plc000000014qocwkh25d7xqgux3j3oh','place',NULL,'parent','root',1),(1092,'mda000000014qocwqq8vt5dfqn1l1c9y','media',NULL,'label','/codemirror/mode/css.js',1),(1093,'plc000000014qocwqs411jrv6355wyoc','place',NULL,'label','/codemirror/mode/css.js',1),(1094,'plc000000014qocwqs411jrv6355wyoc','place',NULL,'parent','root',1),(1095,'mda000000014qocwxrjnsnazg5uikde2','media',NULL,'label','/codemirror/mode/javascript.js',1),(1096,'plc000000014qocwxsxdpzwku2szuh6q','place',NULL,'label','/codemirror/mode/javascript.js',1),(1097,'plc000000014qocwxsxdpzwku2szuh6q','place',NULL,'parent','root',1),(1098,'mda000000014qow8qn3ahwzu952lrhfo','media',NULL,'label','///',1),(1099,'plc000000014qow8qoe17z4o9racuhfd','place',NULL,'label','new ///',1),(1100,'plc000000014qow8qoe17z4o9racuhfd','place',NULL,'parent','root',1),(1110,'mda000000014qpe9te1cyto3lt7mxva6','media',NULL,'label','codemirror php.js',1),(1111,'plc000000014qpe9tfpofbf9l5rqbkum','place',NULL,'label','codemirror php.js',1),(1112,'plc000000014qpe9tfpofbf9l5rqbkum','place',NULL,'parent','root',1),(1113,'mda000000014qpe9vqy0qq5bpmcbtcdg','media',NULL,'label','codemirror clike.js',1),(1114,'plc000000014qpe9vspipeo6n7zcs21v','place',NULL,'label','codemirror clike.js',1),(1115,'plc000000014qpe9vspipeo6n7zcs21v','place',NULL,'parent','root',1),(1119,'mda000000014qphjzial4zx0k19295nd','media',NULL,'label','codemirror search.js',1),(1120,'plc000000014qphjzk4c53jlidsl0wfz','place',NULL,'label','codemirror search.js',1),(1121,'plc000000014qphjzk4c53jlidsl0wfz','place',NULL,'parent','root',1),(1122,'mda000000014qphk3qgaj54tzqarmbd2','media',NULL,'label','codemirror dialog.js',1),(1123,'plc000000014qphk3soqr7t1q3cbmngc','place',NULL,'label','codemirror dialog.js',1),(1124,'plc000000014qphk3soqr7t1q3cbmngc','place',NULL,'parent','root',1),(1125,'mda000000014qphk88zd3kgyohkpob3a','media',NULL,'label','codemirror dialog.css',1),(1126,'plc000000014qphk8ar0r7bw8croh4j0','place',NULL,'label','codemirror dialog.css',1),(1127,'plc000000014qphk8ar0r7bw8croh4j0','place',NULL,'parent','root',1),(1128,'mda000000014qphl8gy9lbpdqpogvqe6','media',NULL,'label','codemirror searchcursor.js',1),(1129,'plc000000014qphl8iotpy2n8qsqvtqe','place',NULL,'label','codemirror searchcursor.js',1),(1130,'plc000000014qphl8iotpy2n8qsqvtqe','place',NULL,'parent','root',1),(1131,'launchpad2','interface',NULL,'label','launcher',1);
/*!40000 ALTER TABLE `mvs_meta` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mvs_packages`
--

DROP TABLE IF EXISTS `mvs_packages`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mvs_packages` (
  `package_id` int(11) NOT NULL AUTO_INCREMENT,
  `package_GUID` varchar(32) NOT NULL,
  `contents` text NOT NULL,
  PRIMARY KEY (`package_id`),
  UNIQUE KEY `package_GUID` (`package_GUID`)
) ENGINE=InnoDB AUTO_INCREMENT=48 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mvs_packages`
--

LOCK TABLES `mvs_packages` WRITE;
/*!40000 ALTER TABLE `mvs_packages` DISABLE KEYS */;
INSERT INTO `mvs_packages` VALUES (1,'home','[{\"movabl_type\":\"place\",\"movabl_GUID\":\"root\"},{\"movabl_type\":\"media\",\"movabl_GUID\":\"TEST_MEDIA\"},{\"movabl_type\":\"interface\",\"movabl_GUID\":\"TEST_INT\"}]'),(2,'movabls_ide','[{\"movabl_type\":\"place\",\"movabl_GUID\":\"movabls\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"launchpad\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"basejs\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"Slash404\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"function\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"media\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"place\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"Set_Function\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"Set_Interface\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"Set_Media\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"Set_Place\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"tabscss\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"tabsjs\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"interface\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014h5bclzgokpuqyu135c8e\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014h5bckansh42un5fesnf8\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014h5a7m2lc0mb5485k7ju9\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014gsd7r8fcewqmu5fc9p9e\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014h5aurlm4fh47m5lrel30\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014gsd7lbxcj083es1ofzxg\"},{\"movabl_type\":\"media\",\"movabl_GUID\":\"mda000000014qocmi1dw4lpwq5lzmnbq\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qocmi38hpew34ro4ppuz\"},{\"movabl_type\":\"media\",\"movabl_GUID\":\"mda000000014qow8qn3ahwzu952lrhfo\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qow8qoe17z4o9racuhfd\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qozsc7gwjyyk7qitine3\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qozsj1jbjtqg5pg7yn8n\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qozwn6pmodo9ssceqxz4\"}]'),(47,'pkg000000014qocp8n1jyedpzud01io7','[{\"movabl_type\":\"media\",\"movabl_GUID\":\"mda000000014qocp8oapfg3gx2z9z6xj\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qocp8pr75epkjtdvjjkq\"},{\"movabl_type\":\"media\",\"movabl_GUID\":\"mda000000014qocpj4tg1wpei36gtex3\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qocpj66mxnnltcayx0eu\"},{\"movabl_type\":\"media\",\"movabl_GUID\":\"mda000000014qoctcucxomfmjozusrbq\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qoctcvy9dvsyik9lk2a0\"},{\"movabl_type\":\"media\",\"movabl_GUID\":\"mda000000014qocw4oe9bn9y4noxu6o0\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qocw4q04j5adbrp4xoya\"},{\"movabl_type\":\"media\",\"movabl_GUID\":\"mda000000014qocwkfofeqtkarene37i\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qocwkh25d7xqgux3j3oh\"},{\"movabl_type\":\"media\",\"movabl_GUID\":\"mda000000014qocwqq8vt5dfqn1l1c9y\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qocwqs411jrv6355wyoc\"},{\"movabl_type\":\"media\",\"movabl_GUID\":\"mda000000014qocwxrjnsnazg5uikde2\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qocwxsxdpzwku2szuh6q\"},{\"movabl_type\":\"media\",\"movabl_GUID\":\"mda000000014qpe9te1cyto3lt7mxva6\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qpe9tfpofbf9l5rqbkum\"},{\"movabl_type\":\"media\",\"movabl_GUID\":\"mda000000014qpe9vqy0qq5bpmcbtcdg\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qpe9vspipeo6n7zcs21v\"},{\"movabl_type\":\"media\",\"movabl_GUID\":\"mda000000014qphjzial4zx0k19295nd\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qphjzk4c53jlidsl0wfz\"},{\"movabl_type\":\"media\",\"movabl_GUID\":\"mda000000014qphk3qgaj54tzqarmbd2\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qphk3soqr7t1q3cbmngc\"},{\"movabl_type\":\"media\",\"movabl_GUID\":\"mda000000014qphk88zd3kgyohkpob3a\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qphk8ar0r7bw8croh4j0\"},{\"movabl_type\":\"media\",\"movabl_GUID\":\"mda000000014qphl8gy9lbpdqpogvqe6\"},{\"movabl_type\":\"place\",\"movabl_GUID\":\"plc000000014qphl8iotpy2n8qsqvtqe\"}]');
/*!40000 ALTER TABLE `mvs_packages` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mvs_permissions`
--

DROP TABLE IF EXISTS `mvs_permissions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mvs_permissions` (
  `permissions_id` int(11) NOT NULL AUTO_INCREMENT,
  `group_id` int(11) NOT NULL,
  `movabl_type` enum('site','package','place','interface','media','function') NOT NULL,
  `movabl_GUID` varchar(32) DEFAULT NULL,
  `permission_type` enum('read','write','execute') NOT NULL,
  `inheritance_type` enum('site','package','place','interface','media','function') DEFAULT NULL,
  `inheritance_GUID` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`permissions_id`),
  UNIQUE KEY `unique` (`permissions_id`,`movabl_type`,`movabl_GUID`,`permission_type`,`inheritance_type`,`inheritance_GUID`)
) ENGINE=InnoDB AUTO_INCREMENT=65974 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mvs_permissions`
--

LOCK TABLES `mvs_permissions` WRITE;
/*!40000 ALTER TABLE `mvs_permissions` DISABLE KEYS */;
INSERT INTO `mvs_permissions` VALUES (65950,1,'media','mda000000014qow8qn3ahwzu952lrhfo','read',NULL,NULL),(65951,1,'media','mda000000014qow8qn3ahwzu952lrhfo','write',NULL,NULL),(65952,1,'media','mda000000014qow8qn3ahwzu952lrhfo','execute',NULL,NULL),(65953,1,'interface','launchpad2','read',NULL,NULL),(65954,1,'interface','launchpad2','write',NULL,NULL),(65955,1,'interface','launchpad2','execute',NULL,NULL),(65956,1,'media','place','read',NULL,NULL),(65957,1,'media','place','write',NULL,NULL),(65958,1,'media','place','execute',NULL,NULL),(65959,1,'function','encode_inputs','read','interface','function'),(65960,1,'function','encode_inputs','write','interface','function'),(65961,1,'function','encode_inputs','execute','interface','function'),(65962,1,'interface','function','read',NULL,NULL),(65963,1,'interface','function','write',NULL,NULL),(65964,1,'interface','function','execute',NULL,NULL),(65965,1,'function','mapinterface','read','interface','interface'),(65966,1,'function','mapinterface','write','interface','interface'),(65967,1,'function','mapinterface','execute','interface','interface'),(65968,1,'interface','interface','read',NULL,NULL),(65969,1,'interface','interface','write',NULL,NULL),(65970,1,'interface','interface','execute',NULL,NULL),(65971,1,'media','TEST_MEDIA','read',NULL,NULL),(65972,1,'media','TEST_MEDIA','write',NULL,NULL),(65973,1,'media','TEST_MEDIA','execute',NULL,NULL);
/*!40000 ALTER TABLE `mvs_permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mvs_permissions_packages`
--

DROP TABLE IF EXISTS `mvs_permissions_packages`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mvs_permissions_packages` (
  `permissions_id` int(11) NOT NULL AUTO_INCREMENT,
  `group_id` int(11) NOT NULL,
  `movabl_type` enum('site','package','place','interface','media','function') NOT NULL,
  `movabl_GUID` varchar(32) DEFAULT NULL,
  `permission_type` enum('read','write','execute') NOT NULL,
  `inheritance_type` enum('site','package','place','interface','media','function') DEFAULT NULL,
  `inheritance_GUID` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`permissions_id`),
  UNIQUE KEY `unique` (`permissions_id`,`movabl_type`,`movabl_GUID`,`permission_type`,`inheritance_type`,`inheritance_GUID`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mvs_permissions_packages`
--

LOCK TABLES `mvs_permissions_packages` WRITE;
/*!40000 ALTER TABLE `mvs_permissions_packages` DISABLE KEYS */;
/*!40000 ALTER TABLE `mvs_permissions_packages` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mvs_places`
--

DROP TABLE IF EXISTS `mvs_places`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mvs_places` (
  `place_id` int(11) NOT NULL AUTO_INCREMENT,
  `place_GUID` varchar(32) NOT NULL,
  `url` varchar(255) NOT NULL,
  `inputs` text,
  `https` tinyint(1) NOT NULL,
  `media_GUID` varchar(32) NOT NULL,
  `interface_GUID` varchar(32) DEFAULT NULL,
  PRIMARY KEY (`place_id`),
  UNIQUE KEY `place_GUID` (`place_GUID`),
  UNIQUE KEY `url` (`url`)
) ENGINE=InnoDB AUTO_INCREMENT=315 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mvs_places`
--

LOCK TABLES `mvs_places` WRITE;
/*!40000 ALTER TABLE `mvs_places` DISABLE KEYS */;
INSERT INTO `mvs_places` VALUES (2,'root','/',NULL,0,'TEST_MEDIA','int000000014lcn2c3m92oq5tkmt9k1g'),(12,'place','///~/Place/%',NULL,0,'place','place'),(17,'function','///~/Function/%',NULL,0,'function','function'),(18,'interface','///~/Interface/%',NULL,0,'mda000000014h5a7m1l8osd0tsw41flr','interface'),(21,'basejs','///~/base.js',NULL,0,'basejs',NULL),(27,'Set_Media','///~/Set/Media/%',NULL,0,'Set_Media','Set_Media'),(28,'Set_Function','///~/Set/Function/%',NULL,0,'Set_Function','Set_Function'),(29,'Set_Interface','///~/Set/Interface/%',NULL,0,'Set_Interface','Set_Interface'),(213,'plc000000014lyqp22z9nrf84hu6rotp','///~/user/create','',0,'mda000000014lyqp22tpp8k25mh8wgi7','int00000001glh2dr7pnbpcy78qg6rl'),(214,'plc000000014lyqrasaxc1zgu1boq4u8','/SignIn/%','[\"destination\"]',0,'mda000000014lyqras857620egeb2nof','int000000014lyqqzrupsywpmwe8qbv4'),(216,'plc000000014m06kahp9xarxrkdmevjg','///~/places','',0,'mda000000014m06kahjp4o5a325mllkx','int000000014m06k27mpbe52oinx50wp'),(217,'plc000000014m06kdvb1hphffwsdt4gl','///~/users','',0,'mda000000014m06kdv5hohtdbnmy1ha4','int000000014m06k2yy168hl0rowyh7b'),(218,'plc000000014m06kh0457fuxvhwejse8','///~/packages','',0,'mda000000014m06kgzylc1gi49c513lx','int00000001glm97mulr65ec3esadx7'),(221,'plc000000014m1gq71xx79qmjx1r6thq','///~/group/create','',0,'mda000000014m1gq71v5rm45y8czvbt5','int000000014m1gnlhchxxo0xfz4hb06'),(222,'plc000000014m1ht50jlt88at7gzltpn','///~/package/create','',0,'mda000000011nrwbxht6m4772q81ali','int000000014m1hsqj0lqf7uh3mqszmf'),(292,'plc000000014qocmi38hpew34ro4ppuz','///~/Media/%',NULL,0,'mda000000014qocmi1dw4lpwq5lzmnbq','media'),(293,'plc000000014qocp8pr75epkjtdvjjkq','/codemirror/lib/codemirror.js','',0,'mda000000014qocp8oapfg3gx2z9z6xj',NULL),(294,'plc000000014qocpj66mxnnltcayx0eu','/codemirror/lib/codemirror.css','',0,'mda000000014qocpj4tg1wpei36gtex3',NULL),(295,'plc000000014qoctcvy9dvsyik9lk2a0','/codemirror/theme/elegant.css','',0,'mda000000014qoctcucxomfmjozusrbq',NULL),(296,'plc000000014qocw4q04j5adbrp4xoya','/codemirror/mode/htmlmixed.js','',0,'mda000000014qocw4oe9bn9y4noxu6o0',NULL),(297,'plc000000014qocwkh25d7xqgux3j3oh','/codemirror/mode/xml.js','',0,'mda000000014qocwkfofeqtkarene37i',NULL),(298,'plc000000014qocwqs411jrv6355wyoc','/codemirror/mode/css.js','',0,'mda000000014qocwqq8vt5dfqn1l1c9y',NULL),(299,'plc000000014qocwxsxdpzwku2szuh6q','/codemirror/mode/javascript.js','',0,'mda000000014qocwxrjnsnazg5uikde2',NULL),(300,'plc000000014qow8qoe17z4o9racuhfd','///','',0,'mda000000014qow8qn3ahwzu952lrhfo','launchpad2'),(308,'plc000000014qpe9tfpofbf9l5rqbkum','/codemirror/mode/php.js','',0,'mda000000014qpe9te1cyto3lt7mxva6',NULL),(309,'plc000000014qpe9vspipeo6n7zcs21v','/codemirror/mode/clike.js','',0,'mda000000014qpe9vqy0qq5bpmcbtcdg',NULL),(311,'plc000000014qphjzk4c53jlidsl0wfz','/codemirror/util/search.js','',0,'mda000000014qphjzial4zx0k19295nd',NULL),(312,'plc000000014qphk3soqr7t1q3cbmngc','/codemirror/util/dialog.js','',0,'mda000000014qphk3qgaj54tzqarmbd2',NULL),(313,'plc000000014qphk8ar0r7bw8croh4j0','/codemirror/util/dialog.css','',0,'mda000000014qphk88zd3kgyohkpob3a',NULL),(314,'plc000000014qphl8iotpy2n8qsqvtqe','/codemirror/util/searchcursor.js','',0,'mda000000014qphl8gy9lbpdqpogvqe6',NULL);
/*!40000 ALTER TABLE `mvs_places` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mvs_sessiondata`
--

DROP TABLE IF EXISTS `mvs_sessiondata`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mvs_sessiondata` (
  `sessiondata_id` int(11) NOT NULL AUTO_INCREMENT,
  `session_id` int(11) NOT NULL,
  `key` varchar(128) NOT NULL,
  `value` text NOT NULL,
  PRIMARY KEY (`sessiondata_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mvs_sessiondata`
--

LOCK TABLES `mvs_sessiondata` WRITE;
/*!40000 ALTER TABLE `mvs_sessiondata` DISABLE KEYS */;
/*!40000 ALTER TABLE `mvs_sessiondata` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mvs_sessions`
--

DROP TABLE IF EXISTS `mvs_sessions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mvs_sessions` (
  `session_id` int(11) NOT NULL AUTO_INCREMENT,
  `sslsession` varchar(64) NOT NULL,
  `sslrequests` varchar(64) NOT NULL,
  `httpsession` varchar(64) NOT NULL,
  `httprequests` varchar(64) NOT NULL,
  `user_id` int(11) NOT NULL,
  `term` int(11) NOT NULL,
  `expiration` datetime DEFAULT NULL,
  PRIMARY KEY (`session_id`)
) ENGINE=InnoDB AUTO_INCREMENT=17591 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mvs_sessions`
--

LOCK TABLES `mvs_sessions` WRITE;
/*!40000 ALTER TABLE `mvs_sessions` DISABLE KEYS */;
INSERT INTO `mvs_sessions` VALUES (17590,'fa05c81978ff19366b3fad5ed2f73bff75c9aa854fbc79c3aa8802.30420305','','ea5582d87c0ef1704bc31cf50b5f0e0520e6f2e14fbc79c3aa8af7.33567562','',6,2629743,'2012-06-22 12:17:05');
/*!40000 ALTER TABLE `mvs_sessions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `mvs_users`
--

DROP TABLE IF EXISTS `mvs_users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `mvs_users` (
  `user_id` int(11) NOT NULL AUTO_INCREMENT,
  `password` varchar(128) NOT NULL,
  `nonce` varchar(32) NOT NULL,
  `user_GUID` varchar(32) DEFAULT NULL,
  `email` varchar(128) DEFAULT NULL,
  `name` varchar(128) NOT NULL,
  `twitter` varchar(64) NOT NULL,
  PRIMARY KEY (`user_id`),
  UNIQUE KEY `user_GUID` (`user_GUID`),
  UNIQUE KEY `email` (`email`)
) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `mvs_users`
--

LOCK TABLES `mvs_users` WRITE;
/*!40000 ALTER TABLE `mvs_users` DISABLE KEYS */;
INSERT INTO `mvs_users` VALUES (1,'5b545468bf73716912c9f4a957f2797fc96c83002ae8616dca2dd98b7e22e2c7c466a840d7a0793e745928cdc9ea4431d50661466fdf17c9b50c1d7f327a2cc1','2d608b5d257d7596596abdbdbe5c7af0',NULL,'test@test.test','',''),(6,'a4982df94ebdbdeffd78a9a4800dcd050a24ad22b63977aec35c63a90be19d3781d1563a66be9f59cc55a2790769187f2809cb4554c9436764ff9cbc8875aca4','2518095ebf664a8959d6f173c49766a0','0','tdonia@gmail.com','TD','movabls'),(7,'7a91d47c27a5aabea3adc01bacc073c4bb5e87e6d858cd9b1f64f0a7b39ee894f9df8bbd7f8e44aaaa6a10bb3911c21d5477829061765b5762020363467d5bab','438cc824ae8a75fe1f6d2a8a0f9bd39f',NULL,'public','','');
/*!40000 ALTER TABLE `mvs_users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2012-05-23  5:59:38
